[["index.html", "Introduction to Theoretical Ecology Course Information", " Introduction to Theoretical Ecology Instructor: Po-Ju Ke \\(~~~~~\\) Teaching Assistant: Gen-Chang Hsu 2021 Fall at National Taiwan Univeristy Course Information IMPORTANT ANOUNCEMENT!!! The first three weeks of this course will be online. We will host the two modules of this course (i.e., 2-hr lecture and 1-hr practice) on different platforms. We will use Google Meet for the lecture section (link here). To mimic an environment where we can provide one-on-one coding advice, we will use Gather Town for the hands-on practice section (link here). Please login in advance to make sure it is working; learn how to use Gather Town here. For those who wish to enroll manually, please join the first lecture and stay online afterward. Since we have moved to a larger classroom due to COVID-19 regulation, we can accommodate more students. We have asked students to introduce themselves (e.g., research interest and familiarity with R; 1-2 minutes) during the first time we meet online, so please also be prepared if you wish to enroll. Description The development of theory plays an important role in advancing ecology as a scientific field. This three-unit course is for students at the graduate or advanced undergraduate level. The course will cover classic theoretical topics in ecology, starting from single-species dynamics and gradually build up to multi-species models. The course will primarily focus on population and community ecology, but we will also briefly discuss models in epidemiology and ecosystem ecology. Emphasis will be on theoretical concepts and corresponding mathematical approaches. This course is designed as a two-hour lecture followed by a one-hour hands-on practice module. In the lecture, we will analyze dynamical models and derive general theories in ecology. In the hands-on practice section, we will use a combination of analytical problem sets, interactive applications, and numerical simulations to gain a general understanding of the dynamics and behavior of different models. Objectives By the end of the course, students are expected to be familiar with the basic building blocks of ecological models and would be able to formulate and analyze simple models of their own. The hands-on practice component should allow students to link their ecological intuition with the underlying mathematical model, helping them to better understand the primary literature of theoretical ecology. Requirements Students are expected to have a basic understanding of Calculus (e.g., freshman introductory course) and Ecology. Format Tuesday 1:20 pm ~ 4:20 pm at Classroom 3C, Life Science Building Lecture (two hours): selected topics of ecological theories and models (blackboard writing) Lab (one hour): hands-on practice in programming and simulation (using R) + discussion Grading The final grade consists of: Assignment problem sets (60%) Midterm exam (15%) Final exam (15%) Course participation (10%) Course materials We will be using a combination of textbooks and literature articles on theoretical ecology in this course. Textbook chapters and additional reading materials will be provided (see Syllabus for more details). Below are the textbook references: Case, Ted J. An illustrated guide to theoretical ecology. Oxford University Press, 2000. Gotelli, Nicholas J. A primer of ecology 4th edition. Sinauer Associates, 2008. Pastor, John. Mathematical ecology of populations and ecosystems. John Wiley &amp; Sons, 2011. Otto, Sarah P. and Troy Day. A biologists guide to mathematical modeling in ecology and evolution. Princeton University Press, 2011. Contacts Instructor: Po-Ju Ke Office: Life Science Building R635 Email: pojuke@ntu.edu.tw Office hours: by appointment Teaching assistant: Gen-Chang Hsu Email: b04b01065@ntu.edu.tw Office hours: by appointment "],["syllabus.html", "Syllabus", " Syllabus Date Lecture topic Lab Readings Week 1 28-Sept-2021 Introduction: what is theoretical ecology? - Grainger et al., 2021 Week 2 05-Oct-2021 Exponential population growth Solving exponential growth equation using deSolve &amp; Visualization Gotelli [Ch.1] Case [Ch.1] Week 3 12-Oct-2021 Logistic population growth and stability analysis Solving logistic growth equation using deSolve &amp; Visualization Gotelli [Ch.2] Case [Ch.5] Otto &amp; Day [Ch.5] Week 4 19-Oct-2021 Discrete exponential and logistic models Modeling discrete logistic growth using for loops &amp; Visualization May, 1976 Week 5 26-Oct-2021 Age-structured models Analyzing Leslie matrix using for loops and eigenanalysis Gotelli [Ch.3] Case[Ch.3] Week 6 02-Nov-2021 Metapopulations and patch occupancy models Building and analyzing a model on plant-soil dynamics Gotelli [Ch.4] Case [Ch.16] Week 7 09-Nov-2021 Lotka-Volterra model of competition: graphical analysis Visualizing state-phase diagrams of Lotka-Volterra competition model Gotelli [Ch.5] Case [Ch.14] Week 8 16-Nov-2021 Lotka-Volterra model of competition: linear stability analysis Analyzing system dynamics of Lotka-Volterra competition model Otto &amp; Day [Ch.8] Week 9 23-Nov-2021 Midterm exam - \\(~~~~~~~~~~~~\\) - Week 10 30-Nov-2021 Modern coexistence theory &amp; Lotka-Volterra model of predator-prey interactions (1) Analyzing Lotka-Volterra model of predator-prey interactions (basic) Broekman et al., 2019 Week 11 07-Dec-2021 Lotka-Volterra model of predator-prey interactions (2) Analyzing Lotka-Volterra model of predator-prey interactions (variants) Gotelli [Ch.6] Case [Ch.12 &amp; 13] Week 12 14-Dec-2021 Resource competition: R* models Analyzing the dynamics of various consumer-resource systems Armstrong &amp; McGehee, 1980 Tilman, 1980 Week 13 21-Dec-2021 Multispecies models of competition: apparent competition Visualizing the area of prey coexistence under apparent competition Holt, 1977 Week 14 28-Dec-2021 Disease dynamics and SIR models Analyzing the SIR model with demography &amp; Visualization Anderson &amp; May, 1979 Week 15 04-Jan-2022 Course review &amp; open discussion - TBA Week 16 11-Jan-2022 Final exam - \\(~~~~~~~~~~~~\\) - "],["week-1.html", "Week 1 Lecture in a nutshell Lab demonstration Additional readings Assignments", " Week 1 Introduction: what is theoretical ecology? Lecture in a nutshell Lecture handout Introduction to ecological theories and mathematical models Constructing ecological models: 5 steps Step 1. Formulate the motivating question Step 2. Determine the basic ingredients Step 3. Qualitatively describe the biological system Step 4. Quantitatively describe the biological system Step 5. Analyze the model Apply ecological models in your study: 4 approaches Approach 1. Adopt the framework Approach 2. Test the predictions Approach 3. Use the equations (model fitting/proxy calculation) Approach 4. Test model assumptions Some relevant math techniques: Derivatives and integrals, linear approximation and Taylor expansion Lab demonstration No lab demonstration this week. Additional readings Grainger et al.Â (2021). An empiricists guide to using ecological theory. American Naturalist. Assignments Please review the study material and make sure you understand the basic R syntax and programming fundamentals, which we will be using throughout the semester. The example dataset for the tutorial is provided below. Basic Introduction to R Example dataset "],["week-2.html", "Week 2 Lecture in a nutshell Lab demonstration Additional readings Assignments", " Week 2 Exponential population growth Lecture in a nutshell Model derivation: Population growth rate: \\(Birth - Death + Immigration - Emigration\\) Per capita growth rate: \\((birth - death + immigration - emigration)\\times N\\). Assumptions: Closed population: \\(Immigration\\) = \\(Emigration = 0\\) All individuals are identical: no genetic/age/stage structure Continuous population growth: no time lag Per capita birth and death rates are constant: time- and density-independent Solving the differential equation \\(\\frac{dN}{dt} = (b-d)N\\): Use separation of variables and integrate both sides Plug in the initial condition \\(N_0\\) at \\(t = 0\\) Integration result: \\(N_{(t)} = N_0e^{(b-d)t} = N_0e^{rt}\\) Related concept: Doubling time \\(t_d = \\frac{ln(2)}{r}\\) Average (expected) lifetime for an exponential decay function \\(N_{(t)} = N_0e^{-\\delta t}\\): Probability density function (PDF): \\(\\frac{N_0e^{-\\delta t} - N_0e^{-\\delta (t+\\Delta t)}}{N_0} \\approx \\delta e^{-\\delta t}\\) (linear approximation) Expected value: \\(\\int_{0}^{\\infty}t\\delta e^{-\\delta t}dt\\) Use integration by parts to evaluate the integral Integration result: \\(\\frac{1}{\\delta}\\) Relaxation of assumption 1: Net immigration/emigration is not zero: \\(\\frac{dN}{dt} = rN + I_{(t)}\\) Solve the equation using the general solution to first-order linear differential equations Relaxation of assumption 4: Per capita growth rate \\(r\\) is not a constant but rather a function of time: \\(\\frac{dN}{dt} = r_{(t)}N\\) An example of \\(r_{(t)}\\): \\(r_{(t)} = \\overline{r} + \\frac{\\sigma}{2}sin(\\omega t + \\phi)\\) Biological interpretation of \\(r_{(t)}\\): seasonality, environmental fluctuations, etc. Lab demonstration In this lab, we will be solving the differential equation for exponential population growth (Part 1) and visualize how the population sizes change over time (Part 2). Part 1 - Numerical solution using the package deSolve Two main phases: Model specification: specify the structure of differential equation model Model application: set the time steps, initial population size, model parameters (e.g., intrinsic population growth rate r) and solve the equation p span#aaa:before { content: \"(1) \"; display: inline-block; margin-left: -1.5em; margin-right: 0.3em; } p span#bbb:before { content: \"(2) \"; display: inline-block; margin-left: -1.5em; margin-right: 0.3em; } d-article table.lightable-paper { margin-bottom: 0px; } # install.packages(&quot;deSolve&quot;) library(deSolve) ### (1) Model specification exponential_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N # exponential growth equation return(list(c(dN_dt))) # return the results }) } ### (2) Model application times &lt;- seq(0, 10, by = 0.1) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r = 1.5) # intrinsic growth rate # run the ode solver pop_size &lt;- ode(func = exponential_model, times = times, y = state, parms = parms) # take a look at the results head(pop_size) ## time N ## [1,] 0.0 10.00000 ## [2,] 0.1 11.61834 ## [3,] 0.2 13.49860 ## [4,] 0.3 15.68313 ## [5,] 0.4 18.22120 ## [6,] 0.5 21.17002 Part 2. Visualize the integration results: Linear scale # install.packages(&quot;tidyverse&quot;) library(tidyverse) ggplot(data = as.data.frame(pop_size), aes(x = time, y = N)) + geom_point() + labs(title = paste0(&quot;Exponential Growth \\n (r = &quot;, parms[&quot;r&quot;], &quot;)&quot;)) + theme_classic(base_size = 12) + theme(plot.title = element_text(hjust = 0.5)) + scale_x_continuous(limits = c(0, 10.5), expand = c(0, 0)) + scale_y_continuous(limits = c(0, max(as.data.frame(pop_size)$N)*1.1), expand = c(0, 0)) Log scale ggplot(data = as.data.frame(pop_size), aes(x = time, y = N)) + geom_point() + labs(title = paste0(&quot;Exponential Growth \\n (r = &quot;, parms[&quot;r&quot;], &quot;)&quot;)) + theme_classic(base_size = 12) + theme(plot.title = element_text(hjust = 0.5)) + scale_x_continuous(limits = c(0, 10.5), expand = c(0, 0)) + scale_y_log10(breaks = scales::trans_breaks(&quot;log10&quot;, function(x) 10^x)(c(10, 10^7)), labels = scales::trans_format(&quot;log10&quot;, scales::math_format(10^.x)), expand = c(0, 0)) Additional readings Package deSolve: Solving Initial Value Differential Equations in R Assignments Exponential Population Growth with Constant Immigration Suggested Solutions "],["week-3.html", "Week 3 Lecture in a nutshell Lab demonstration Additional readings Assignments", " Week 3 Logistic population growth and stability analysis Lecture in a nutshell Model derivation: Population growth rate: \\(Birth - Death + Immigration - Emigration\\) Per capita growth rate: \\((birth - death + immigration - emigration)\\times N\\). Assumptions: Closed population: \\(Immigration\\) = \\(Emigration = 0\\) All individuals are identical: no genetic/age/stage structure Continuous population growth without time lag Per capita birth and death rates are time-independent BUT density-dependent Resource is limited: negative density-dependence (NDD) \\(\\frac{dr_{(N)}}{dt} &lt; 0\\) Linear density-dependence: \\(b_{(n)} = b_{0}-b_{N}N\\); \\(d_{(n)} = d_{0}+d_{N}N\\) \\(\\begin{aligned}\\frac{dN}{dt}&amp;=(b_{0}-b_{N}N-d_{0}-d_{N}N)N\\\\&amp;=((b_{0}-d_{0})-(d_{N}+b_{N})N)N\\\\&amp;=(r_{0}-\\alpha N)N\\\\&amp;=r_{0}N(1-\\frac{N}{K})\\end{aligned}\\) Integration of the differential equation \\(N_{(t)} = \\frac{K}{1-\\frac{N_{0}-K}{N_{0}}e^{-r_{0}t}}\\) Equilibrium \\(N^*\\): good candidates where the system will end up \\(\\frac{dN}{dt} = f_{(N^*)} = r_{0}N^{*}(1-\\frac{N^*}{K}) = 0\\); \\(N^* = 0, K\\) Attracting (Stable) vs.Â Repelling (Unstable) vs.Â Saddle Graphical analysis Plot the function \\(\\frac{dN}{dt} = f(N)\\) and determine the direction of change (positive/negative) on both sides of the equilibrium points \\(N^*\\) Local stability analysis A small displacement from the equilibrium: \\(\\epsilon_{(t)} = N - N^*\\) Examine how \\(\\epsilon_{(t)}\\) changes over time (i.e., the behavior of the small displacement): \\(\\frac{d\\epsilon_{(t)}}{dt} = f(N-N^*) = f(N^*) + \\epsilon \\frac{dN}{dt}|_{N = N^*} + O_{(\\epsilon^2)} \\approx \\epsilon\\frac{dN}{dt}|_{N = N^*} = \\lambda \\epsilon\\); \\(\\epsilon_{(t)} = \\epsilon_{0}e^{\\lambda t}\\) (the behavior of \\(\\epsilon_{(t)}\\) is determined by the sign of \\(\\lambda\\)) General procedure: take derivative of the differential equation with respect to \\(N\\) and evaluate it at the equilibrium point \\(N^*\\): \\(\\frac{dN}{dt}|_{N = N^*} = \\lambda &gt; 0\\): unstable equilibrium \\(\\frac{dN}{dt}|_{N = N^*} = \\lambda &lt; 0\\): stable equilibrium Lab demonstration In this lab, we will solve the differential equation for logistic population growth and visualize how the population sizes change over time. Have a quick review of the lab section in Week 2. We will also take a look at how population growth rate (\\(\\frac{dN}{dt}\\)) and per capita growth rate (\\(\\frac{dN}{dtN}\\)) change with population size (\\(N\\)). Part 1 - Solving the logistic growth equation and visualize the results library(tidyverse) library(deSolve) ### Model specification logistic_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N*(K-N)/K # logistic growth equation return(list(c(dN_dt))) # return the results }) } ### Model application times &lt;- seq(0, 10, by = 0.1) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r = 1.5, K = 500) # intrinsic growth rate and carrying capacity # run the ode solver pop_size &lt;- ode(func = logistic_model, times = times, y = state, parms = parms) ### Visualize the results ggplot(data = as.data.frame(pop_size), aes(x = time, y = N)) + geom_point() + labs(title = paste0(&quot;Logistic Growth \\n (r = &quot;, parms[&quot;r&quot;], &quot;, K = &quot;, parms[&quot;K&quot;], &quot;)&quot;)) + theme_classic(base_size = 12) + theme(plot.title = element_text(hjust = 0.5)) + scale_x_continuous(limits = c(0, 10.5), expand = c(0, 0)) + scale_y_continuous(limits = c(0, max(as.data.frame(pop_size)$N)*1.1), expand = c(0, 0)) iframe {border: 0;} Here is an interactive web app for the logistic growth model. Feel free to play around with the parameters/values and see how the population trajectories change. Please select a set of parameters of your choice and reproduce the output figure you see in this app. Part 2 - The relationship between population growth rate (\\(\\frac{dN}{dt}\\))/per capita growth rate (\\(\\frac{dN}{dtN}\\)) and population size (\\(N\\)) # parameters r &lt;- 1.5 K &lt;- 500 # a vector of population sizes N &lt;- 0:600 # calculate the population growth rates and per capita growth rates dN_dt &lt;- r*N*(K-N)/K dN_dtN &lt;- r*(K-N)/K # organize into a dataframe logistic_data &lt;- data.frame(N, dN_dt, dN_dtN) %&gt;% pivot_longer(cols = c(dN_dt, dN_dtN), names_to = &quot;vars&quot;, values_to = &quot;values&quot;) # plot K_df &lt;- data.frame(xend = c(500, 500), yend = c(20, 0.1), xstart = c(500, 500), ystart = c(100, 0.5), labels = c(&quot;italic(K)&quot;, &quot;italic(K)&quot;), vars = c(&quot;dN_dt&quot;, &quot;dN_dtN&quot;)) ggplot(data = logistic_data, aes(x = N, y = values)) + geom_line(size = 1.2) + geom_point(x = 500, y = 0, size = 4, color = &quot;blue&quot;) + geom_hline(yintercept = 0, linetype = &quot;dashed&quot;, color = &quot;red&quot;, size = 1.2) + labs(x = &quot;N&quot;, y = &quot;&quot;) + facet_wrap(~vars, ncol = 2, scales = &quot;free_y&quot;, strip.position = &quot;left&quot;, labeller = as_labeller(c(dN_dt = &quot;dN/dt&quot;, dN_dtN = &quot;dN/dtN&quot;))) + theme_bw(base_size = 12) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, legend.position = &quot;top&quot;, legend.title = element_blank()) + scale_x_continuous(limits = c(0, 610), expand = c(0, 0)) + geom_segment(data = K_df, aes(x = xstart, y = ystart, xend = xend, yend = yend), arrow = arrow(length = unit(0.03, &quot;npc&quot;)), size = 1.2, color = &quot;blue&quot;) + geom_text(data = K_df, aes(x = xstart, y = ystart*1.2, label = labels), size = 5, color = &quot;blue&quot;, parse = T) Additional readings Logistic Growth Assignments Population Growth with Allee Effects Suggested Solutions "],["week-4.html", "Week 4 Lecture in a nutshell Lab demonstration Additional readings Assignments", " Week 4 Discrete exponential and logistic models Lecture in a nutshell Discrete exponential growth (geometric growth): \\(N_{t+1} = RN_{t}; N_{t+1} = R^{t}N_{0}\\) Assumptions: Closed population Identical individuals Unlimited resources: critical rates are constant Discrete growth and census Pre-breeding census: \\(N_{t+1} = (1 + \\beta)(1-\\delta) N_{t} = RN_{t}\\) Cobweb plot: \\(N_{t+1}\\) vs.Â \\(N_{t}\\) Connection to the continuous model:\\(N_{t+\\Delta t} = (1+\\beta \\Delta t)(1-\\delta \\Delta t) N_{t}; \\\\\\frac {dN}{dt} = \\lim_{\\Delta t \\to 0} \\frac {N(t+\\Delta t)-N(t)}{\\Delta t} = \\lim_{\\Delta t \\to 0} (\\beta N_{t}-\\delta N_{t} - \\beta \\delta \\Delta t) = (\\beta-\\delta)N_{t}\\) Relationship between the intrinsic population growth rate r (which is a rate) and the finite rate of increase R (which is unitless): \\(r = \\frac {ln(R)}{h}\\). \\(h\\) is the time interval between two population growth events. Note that R and cannot be directly manipulated; any math computations should be done on r (e.g., divide it by 10), and the modified r can later be converted back to R. Discrete logistic growth: \\(N_{t+1} = N_{t} + rN_{t}(1-\\frac {N_{t}}{K}) = N_{t}(1+r(1- \\frac {N_{t}}{K})) = F_{(N_{t})}\\) The equilibrium \\(N^* = N_{t+1} = N_{t} \\to N^* = 0, K\\) Local stability analysis: A small displacement from the equilibrium point at time \\(t\\): \\(\\epsilon_{t} = N_{t} - N^{*}\\) The behavior of this small displacement at next time step \\(t+1\\): \\(\\begin{aligned}\\epsilon_{t+1}&amp;=N_{t+1}-N^{*}\\\\&amp;=F_{(N_{t+1})}-N^{*}\\\\&amp;=F_{(N^{*}+\\epsilon_{t})}-N^{*}\\\\&amp;=F(N^*)+\\epsilon_{t} \\frac{dF}{dN}|_{N=N^*}+O_{(\\epsilon_{t}^2)}-N^{*} \\\\&amp;\\approx \\epsilon_{t}\\frac{dF}{dN}|_{N = N^*}\\\\&amp;=\\lambda \\epsilon\\end{aligned}\\) Stability criteria: \\(\\lambda &gt; 1\\): unstable (smoothly moving away from the equilibrium) \\(0 &lt; \\lambda &lt; 1\\): stable (smoothly approaching the equilibrium) \\(-1 &lt; \\lambda &lt; 0\\): stable (damped oscillations converging towards the equilibrium) \\(\\lambda &lt; -1\\): unstable (oscillations around the equilibrium) For the discrete logistic model: \\(N^{*} = 0\\) is unstable (\\(\\lambda = 1+r &gt; 1\\)) \\(K\\) is stable only if \\(0 &lt; r &lt; 2\\) (\\(\\lambda = 1-r ~\\&amp;~ |\\lambda| &lt; 1\\)) Lab demonstration In this lab, we are going to model the discrete logistic population growth and visualize the system dynamics. Part 1 - Model the discrete logistic population growth using for loops library(tidyverse) ### (1) Set the parameters r &lt;- 1.8 K &lt;- 500 N0 &lt;- 10 time &lt;- 100 ### (2) Define the discrete logistic growth equation log_fun &lt;- function(r, N, K){N + r*N*(1-N/K)} ### (3) Use for loop to iterate over the time sequence pop_size &lt;- numeric(time) pop_size[1] &lt;- N0 for (i in 2:time) {pop_size[i] &lt;- log_fun(r = r, N = pop_size[i - 1], K = K)} pop_data &lt;- pop_size %&gt;% as.data.frame() %&gt;% rename(., pop_size = `.`) %&gt;% mutate(time = 0:(time-1)) %&gt;% relocate(time) head(pop_data) ## time pop_size ## 1 0 10.00000 ## 2 1 27.64000 ## 3 2 74.64171 ## 4 3 188.93980 ## 5 4 400.51775 ## 6 5 543.95762 Part 2. Visualize the population dynamics: ### Population trajectory ggplot(pop_data, aes(x = time, y = pop_size)) + geom_point() + geom_line() + geom_hline(yintercept = K, color = &quot;red&quot;, size = 1.2, linetype = &quot;dashed&quot;) + geom_text(x = time*1.02, y = K+50, label = &quot;italic(K)&quot;, color = &quot;red&quot;, size = 6.5, parse = T) + labs(y = expression(italic(N)), title = paste0(&quot;Discrete logistic growth&quot;, &quot;\\n&quot;, &quot;(r = &quot;, r, &quot;, K = &quot;, K, &quot;, N0 = &quot;, N0, &quot;)&quot;)) + scale_x_continuous(limits = c(0, time*1.05), expand = c(0, 0)) + scale_y_continuous(limits = c(0, max(pop_size)*1.1), expand = c(0, 0)) + theme_bw(base_size = 15) + theme(plot.title = element_text(hjust = 0.5)) ### Cobweb plot/logistic map cobweb_data &lt;- data.frame(Nt = rep(pop_size[-time], each = 2), Nt1 = c(0, rep(pop_size[-1], each = 2)[-length(rep(pop_size[-1], each = 2))])) logistic_map &lt;- data.frame(Nt = seq(0, (r+1)/r*K, by = 0.1)) %&gt;% mutate(Nt1 = Nt + r*Nt*(1-Nt/K)) ggplot() + geom_line(data = logistic_map, aes(x = Nt, y = Nt1), color = &quot;green&quot;, size = 1.2) + geom_path(data = cobweb_data, aes(x = Nt, y = Nt1), color = &quot;blue&quot;, size = 0.5) + geom_abline(slope = 1, intercept = 0, color = &quot;red&quot;, size = 1) + labs(x = expression(italic(N[t])), y = expression(italic(N[t+1])), title = paste0(&quot;Cobweb plot/logistic map&quot;, &quot;\\n&quot;, &quot;(r = &quot;, r, &quot;, K = &quot;, K, &quot;, N0 = &quot;, N0, &quot;)&quot;)) + scale_x_continuous(limits = c(0, (r+1)/r*K*1.05), expand = c(0, 0)) + scale_y_continuous(limits = c(0, max(pop_size)*1.1), expand = c(0, 0)) + theme_bw(base_size = 15) + theme(plot.title = element_text(hjust = 0.5), panel.grid = element_blank()) *The name logistic map comes from the fact that it maps the population size at one time step Nt to the value at the next time step Nt+1. iframe {border: 0;} Here is a shiny app for the discrete logistic growth model. Feel free to play around with different inputs and see how the system dynamics change accordingly. Additional readings Simple mathematical models with very complicated dynamics Assignments Ricker Logistic Gowth Model Suggested Solutions "],["week-5.html", "Week 5 Lecture in a nutshell Lab demonstration Additional readings Assignments", " Week 5 Age-structured models Lecture in a nutshell Model derivation: Model diagram: a sequence of age classes connected through arrows of survival probability (\\(Si\\)) and fecundity (\\(fi\\)) Assumptions: Closed population Individuals within each age class are identical Critical rates are age-dependent BUT not time- or density-dependent (unlimited resources) Discrete age classes; individuals do not remain in the same age class over time Model dynamics (linear algebra): A simple example: Age class at time t: \\(\\vec{n}_{t} = \\begin{vmatrix}n_{1.t} \\\\ n_{2.t} \\\\ n_{3.t} \\end{vmatrix}\\) Leslie matrix \\(L\\) (transition matrix): \\(\\begin{vmatrix}f_{1} &amp; f_{2} &amp; f_{3}\\\\S_{1} &amp; 0 &amp; 0\\\\0 &amp; S_{2} &amp; 0 \\end{vmatrix}\\) Age class at time t+1: \\(\\vec{n}_{t+1} = L \\cdot \\vec{n}_{t}\\) Eigenanalysis: eigenvalues (\\(\\lambda\\)) and eigenvectors (\\(\\vec{u}\\)) \\(L\\vec{u} = \\lambda\\vec{u}; (L - \\lambda I)\\vec{u} = 0; det|L - \\lambda I| = 0\\) Solve for \\(\\lambda\\) and find the corresponding \\(\\vec{u}\\) Eigendecomposition (for diagonalizable matrix): \\(L = ADA^{-1}; A = \\begin{vmatrix}\\vec{u}_{1} &amp; \\vec{u}_{2} &amp; \\vec{u}_{3} \\end{vmatrix}; D = \\begin{vmatrix}\\lambda_{1} &amp; 0 &amp; 0\\\\0 &amp; \\lambda_{2} &amp; 0\\\\0 &amp; 0 &amp; \\lambda_{3} \\end{vmatrix}\\) \\(L^{t} = AD^{t}A^{-1} \\approx A\\lambda_{1}^{t}A^{-1}\\) (\\(\\lambda_{1}\\) is the dominant eigenvalue) The long-term dynamics of Leslie matrix are determined by: The dominant eigenvalue \\(\\lambda_{1}\\): finite rate of increase (asymptotic growth rate) The dominant eigenvector \\(\\vec{u}_{1}\\): stable age distribution For an \\(n \\times n\\) Leslie matrix, the characteristic equation (Euler-Lotka equation) can be written as: \\(\\sum_{i}^{n} S_{i}f{i}\\lambda^{-i} = 1\\) Stage-structured models: Stages are arbitrarily defined by the user Individuals can remain in the same stage class or even regress back to previous stage class Lab demonstration In this lab, we will be analyzing a simple Leslie matrix using for loops + matrix algebra, comparing the results with those obtained via eigenanalysis, and visualizing the population dynamics and age distribution. Part 1 - Analyzing Leslie matrix library(tidyverse) ### Leslie matrix and initial age classes leslie_mtrx &lt;- matrix(data = c(0, 1, 5, 0.5, 0, 0, 0, 0.3, 0), nrow = 3, ncol = 3, byrow = T) initial_age &lt;- c(10, 0, 0) ### for loop and matrix algebra time &lt;- 50 pop_size &lt;- data.frame(Age1 = numeric(time+1), Age2 = numeric(time+1), Age3 = numeric(time+1)) pop_size[1, ] &lt;- initial_age for (i in 1:time) { pop_size[i+1, ] &lt;- leslie_mtrx %*% as.matrix(t(pop_size[i, ])) } pop_size &lt;- pop_size %&gt;% round() %&gt;% mutate(Total_N = rowSums(.), Time = 0:time) %&gt;% relocate(Time) head(round(pop_size)) ## Time Age1 Age2 Age3 Total_N ## 1 0 10 0 0 10 ## 2 1 0 5 0 5 ## 3 2 5 0 2 7 ## 4 3 8 2 0 10 ## 5 4 2 4 1 7 ## 6 5 8 1 1 10 ### Asymptotic growth rate and stable age distribution asymptotic_growth &lt;- round(pop_size[time+1, 5]/pop_size[time, 5], 3) asymptotic_growth ## [1] 1.091 age_distribution &lt;- round(pop_size[time+1, 2:4]/sum(pop_size[time+1, 2:4]), 3) age_distribution ## Age1 Age2 Age3 ## 51 0.632 0.289 0.079 ### Eigenanalysis of the Leslie matrix eigen_out &lt;- eigen(leslie_mtrx) as.numeric(eigen_out$values[1]) %&gt;% round(., 3) # dominant eigenvalue ## [1] 1.09 as.numeric(eigen_out$vectors[, 1]/sum(eigen_out$vectors[, 1])) %&gt;% round(., 3) # stable age distribution ## [1] 0.631 0.289 0.080 The asymptotic growth rate and stable age distribution obtained from for loops and eigenanalysis are pretty much the same. Part 2 - Visualizing population dynamics and age distribution ### Population sizes for each age class pop_size %&gt;% pivot_longer(cols = -Time, names_to = &quot;Age_class&quot;, values_to = &quot;N&quot;) %&gt;% ggplot(aes(x = Time, y = N, color = Age_class)) + geom_point() + geom_line() + labs(x = &quot;time&quot;, y = expression(italic(N))) + theme_classic(base_size = 12) + scale_x_continuous(limits = c(0, time*1.05), expand = c(0, 0)) + scale_y_log10(limits = c(1, max(pop_size$Total_N)*1.05), expand = c(0, 0)) + scale_color_manual(values = c(&quot;#E41A1C&quot;, &quot;#377EB8&quot;, &quot;#4DAF4A&quot;, &quot;black&quot;), name = NULL, label = c(&quot;Age1&quot;, &quot;Age2&quot;, &quot;Age3&quot;, &quot;Total&quot;)) ### Stable age distribution library(gganimate) age_animate &lt;- pop_size %&gt;% mutate(across(Age1:Age3, function(x){x/Total_N})) %&gt;% select(Time, Age1:Age3) %&gt;% pivot_longer(Age1:Age3, names_to = &quot;Age&quot;, values_to = &quot;Proportion&quot;) %&gt;% ggplot(aes(x = Age, y = Proportion, fill = Age)) + geom_bar(stat = &quot;identity&quot;, show.legend = F) + labs(x = &quot;&quot;) + scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.1), expand = c(0, 0)) + scale_fill_brewer(palette = &quot;Set1&quot;) + theme_classic(base_size = 12) + transition_manual(Time) + ggtitle(&quot;Time {frame}&quot;) + theme(title = element_text(size = 15)) anim_save(&quot;age_distribution.gif&quot;, age_animate, nframes = time + 1, fps = 4, width = 5, height = 4, units = &quot;in&quot;, res = 300) .center { display: block; margin-left: auto; margin-right: auto; width: 70%; } Part 3 - In-class exercise: Analyzing population matrix of common teasel Common teasel (Dipsacus sylvestris) is a herbaceous plant commonly found in abandoned fields and meadows in North America. It has a complex life cycle consisting of various stages. The seeds may lie dormant for one or two years. Seeds that germinate form small rosettes, which will gradually transit into medium and eventually large rosettes. These rosettes (all three sizes) may remain in the same stage for years before entering the next stage. After undergoing vernalization, large (and a few medium) rosettes will form stalks and flower in the upcoming summer, set seeds once, and die. Occasionally, the flowering plants will produce seeds that directly germinate into small/medium/large rosettes without entering dormancy. Here is a transition diagram for the teasel. Please convert this diagram into a stage-based transition matrix (Lefkovitch matrix) and derive the asymptotic growth rate \\(\\lambda\\) in R. Part 4 - Advanced topic: Incorporating density-dependence into Leslie matrix The cell values in a standard Leslie matrix are fixed and independent of population density, leading to an exponential population growth. This assumption can be relaxed by incorporating density-dependence into the transitions (survival probability, fecundity). Here, we will include negative density-dependence for the fecundity of individuals in Age3 class and see how this might affect the long-term population dynamics. ### Leslie matrix, initial age classes, and carrying capacity leslie_mtrx &lt;- matrix(data = c(0, 1, 5, 0.5, 0, 0, 0, 0.3, 0), nrow = 3, ncol = 3, byrow = T) initial_age &lt;- c(10, 0, 0) K &lt;- 300 ### for loop and matrix algebra time &lt;- 150 pop_size_dens_dep &lt;- data.frame(Age1 = numeric(time+1), Age2 = numeric(time+1), Age3 = numeric(time+1)) pop_size_dens_dep[1, ] &lt;- initial_age for (i in 1:time) { N &lt;- sum(pop_size_dens_dep[i, ]) # the current population size leslie_mtrx_dens_dep &lt;- leslie_mtrx # negative density-dependence for the fecundity of individuals in Age3 class ifelse((1-N/K) &gt; 0, leslie_mtrx_dens_dep[1, 3] &lt;- leslie_mtrx_dens_dep[1, 3]*(1-N/K), leslie_mtrx_dens_dep[1, 3] &lt;- 0) pop_size_dens_dep[i+1, ] &lt;- leslie_mtrx_dens_dep %*% as.matrix(t(pop_size_dens_dep[i, ])) } pop_size_dens_dep &lt;- pop_size_dens_dep %&gt;% round() %&gt;% mutate(Total_N = rowSums(.), Time = 0:time) %&gt;% relocate(Time) head(round(pop_size_dens_dep)) ## Time Age1 Age2 Age3 Total_N ## 1 0 10 0 0 10 ## 2 1 0 5 0 5 ## 3 2 5 0 2 7 ## 4 3 7 2 0 9 ## 5 4 2 4 1 7 ## 6 5 7 1 1 9 ### Age distribution age_distribution_dens_dep &lt;- round(pop_size_dens_dep[time+1, 2:4]/sum(pop_size_dens_dep[time+1, 2:4]), 3) age_distribution_dens_dep ## Age1 Age2 Age3 ## 151 0.61 0.3 0.09 ### Total population size pop_size_dens_dep %&gt;% pivot_longer(cols = -Time, names_to = &quot;Age_class&quot;, values_to = &quot;N&quot;) %&gt;% ggplot(aes(x = Time, y = N, color = Age_class)) + geom_point() + geom_line() + labs(x = &quot;time&quot;, y = expression(italic(N))) + theme_classic(base_size = 12) + scale_x_continuous(limits = c(0, time*1.05), expand = c(0, 0)) + scale_y_continuous(limits = c(0, max(pop_size_dens_dep$Total_N)*1.05), expand = c(0, 0)) + scale_color_manual(values = c(&quot;#E41A1C&quot;, &quot;#377EB8&quot;, &quot;#4DAF4A&quot;, &quot;black&quot;), name = NULL, label = c(&quot;Age1&quot;, &quot;Age2&quot;, &quot;Age3&quot;, &quot;Total&quot;)) ### Stable age distribution age_animate_dens_dep &lt;- pop_size_dens_dep %&gt;% mutate(across(Age1:Age3, function(x){x/Total_N})) %&gt;% select(Time, Age1:Age3) %&gt;% pivot_longer(Age1:Age3, names_to = &quot;Age&quot;, values_to = &quot;Proportion&quot;) %&gt;% ggplot(aes(x = Age, y = Proportion, fill = Age)) + geom_bar(stat = &quot;identity&quot;, show.legend = F) + labs(x = &quot;&quot;) + scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.1), expand = c(0, 0)) + scale_fill_brewer(palette = &quot;Set1&quot;) + theme_classic(base_size = 12) + transition_manual(Time) + ggtitle(&quot;Time {frame}&quot;) + theme(title = element_text(size = 15)) anim_save(&quot;age_distribution_dens_dep.gif&quot;, age_animate_dens_dep, nframes = time + 1, fps = 4, width = 5, height = 4, units = &quot;in&quot;, res = 300) Part 5 - COM(P)ADRE: A global database of population matrices COM(P)ADRE is an online repository containing matrix population models on hundreds of plants, animals, algae, fungi, bacteria, and viruses around the world, as well as their associated metadata. Take a look at the website: You will be exploring the population dynamics of a species (of your choice) in your assignment! Additional readings Otto &amp; Day Box 9.1 - Long-Term Dynamics and the Role of the Leading Eigenvalue Assignments Age-Structured Models "],["week-6.html", "Week 6 Lecture in a nutshell Lab demonstration Additional readings Assignments", " Week 6 Metapopulations and patch occupancy models Lecture in a nutshell Metapopulations: A group of local populations linked by dispersal Timescale separation: patch as the basic model unit; ignoring the population dynamics within each patch Assumptions: Homogeneous patches No explicit spatial structure (global dispersal; distance-independent) No time lag Colonization/extinction rates are time-independent but can depend on current occupancy Sufficiently large numbers of patches Modeling the probability (fraction) of patches being occupied \\(P_{(t)}\\): \\(\\\\\\begin{aligned}\\frac{dP}{dt}&amp;=I-E\\\\&amp;=C_{(P)}(1-P)-e_{(P)}P \\\\&amp;= local~colonization - local~extinction \\end{aligned}\\) Mainland-island model: Mainland as a permanent external source of propagules Constant immigration from mainland (i.e., constant colonization rate): \\(C_{(P)} = C_{0}\\) Constant extinction rate of occupied islands: \\(e_{(P)} = e_{0}\\) No dispersal among islands Modeling the patch dynamics: System equation: \\(\\frac{dP}{dt}=C_{0}(1-P)-e_{0}P\\) Equilibrium point \\(P^{*} = \\frac {C_{0}}{C_{0} + e_{0}}\\) Local stability analysis: \\(\\frac {d}{dP}(\\frac {dP}{dt})|_{P = P*} = - (C_{0} + e_{0}) &lt; 0\\) Equilibrium is stable: metapopulations always persist even if \\(C_{0} &lt; e_{0}\\) because mainland is the constant stable propagule source Internal colonization model: No mainland; occupied patches are progagule sources No dispersal among patches Colonization rate depends on current patch occupancy: \\(C_{(P)} = C_{1}P ~ (C_{1} &gt; 0)\\) Constant extinction rate of occupied patches: \\(e_{(P)} = e_{0}\\) Modeling the patch dynamics: System equation: \\(\\frac{dP}{dt}=C_{1}P(1-P)-e_{0}P\\) Equilibrium point \\(P^{*} = 0\\) and \\(1- \\frac {e_{0}}{C_{1}}\\) Local stability analysis: \\(\\frac {d}{dP}(\\frac {dP}{dt})|_{P = P*} = C_{1}(1-P^{*}) - e_{0} - P^{*}C_{1}\\) Equilibrium \\(P^{*} = 1- \\frac {e_{0}}{C_{1}}\\) is stable when \\(C_{1} &gt; e_{0}\\) (\\(P^{*} = 0\\) is unstable) Equilibrium \\(P^{*} = 1- \\frac {e_{0}}{C_{1}}\\) is unstable when \\(C_{1} &lt; e_{0}\\) (\\(P^{*} = 0\\) is stable) Metapopulations may not always persist depending on the relative magnitude of colonization and extinction rate Mainland-island model with rescue effect: Rescue effect: higher overall occupancy will reduce the extinction rate of the islands Constant immigration from mainland: \\(C_{(P)} = C_{0}\\) Extinction rate depends on the fraction of unoccupied islands: \\(e_{(P)} = e_{1}(1-P)\\) Modeling the patch dynamics: System equation: \\(\\frac{dP}{dt}=C_{0}(1-P)-e_{1}(1-P)P\\) Equilibrium point \\(P^{*} = 1\\) and \\(\\frac {C_{0}}{e_{1}}\\) Local stability analysis: \\(\\frac {d}{dP}(\\frac {dP}{dt})|_{P = P*} = -(C_{0}-(e_{1}P^{*}) - (1-P^{*})e_{1}\\) Equilibrium \\(P^{*} = \\frac {C_{0}}{e_{1}}\\) is unstable when \\(C_{0} &gt; e_{1}\\) (\\(P^{*} = 1\\) is stable) Equilibrium \\(P^{*} = \\frac {C_{0}}{e_{1}}\\) is stable when \\(C_{0} &lt; e_{1}\\) (\\(P^{*} = 1\\) is unstable) Metapopulations always persist regardless of the colonization and extinction rate Lab demonstration Plants can condition nearby soil microbial communities, which will in turn influence the performance of subsequent colonizing plants. The soil beneath plant communities are therefore a mosaic with different cultivation histories. Po-Ju wants to understand how plant demographic rates (i.e., colonization and mortality rate) and microbial dynamics (i.e., the conditioning and decay rate of microbial communities) affect the percentage of different soil types in natural forests. As a starting point, Po-Ju builds a one-species patch occupancy model to track the dynamics of different types of plant-soil combination. In this model, he characterizes sites by their plant-soil microbe state, using the notation \\(P_{ij}\\) to indicate sites that are now occupied by plant species \\(i\\) but have soil microbes state \\(j\\). Here, as a single species model, \\(i\\) can be 0 or \\(A\\), representing uncolonized sites or sites colonized by plant \\(A\\), respectively. Similarly, \\(j\\) can be 0 or \\(A\\), indicating sites without recent plant conditioning history or sites conditioned by plant \\(A\\), respectively. In summary: \\(P_{00}\\) represents uncolonized and unconditioned sites \\(P_{A0}\\) represents cites colonized by plant \\(A\\) but the soil is yet to be conditioned \\(P_{AA}\\) represents plant \\(A\\) colonizing a site with plant-\\(A\\)-specific microbial community \\(P_{0A}\\) represents sites that are currently unoccupied but have soil microbes that were associated with plant \\(A\\) At the landscape scale, \\(P_{ij}\\) represents the proportion of sites belonging to a particular plant-soil microbe state, and its dynamics, \\(\\frac {dP_{ij}}{dt}\\), summarizes the processes of plant colonization and death. The transitions between different plant-soil microbe states can be described by the following figure. Here, \\(P_{00}\\) can be colonized by plant \\(A\\) when propagules arrive, transitioning the state from \\(P_{00}\\) to \\(P_{A0}\\). Plants may die, with rate \\(m_{A}\\), before conditioning the soil (i.e., transition from \\(P_{A0}\\) back to \\(P_{00}\\)), or may successfully condition the soil with rate \\(c_{A}\\) (i.e., transition from \\(P_{A0}\\) to \\(P_{AA}\\)). After plants within the state \\(P_{AA}\\) die, a site with microbial legacy is left behind, denoted as \\(P_{0A}\\). These empty sites can be recolonized (i.e., transition from \\(P_{0A}\\) back to \\(P_{AA}\\)) with rates affected by the microbial legacy effect, \\(\\alpha\\). Finally, the microbial community within the soil may decay to unconditioned state with rate \\(d_{A}\\), transitioning the state from \\(P_{0A}\\) to \\(P_{00}\\). In this lab, we are going to model the dynamics of this plant-soil system. We will start by converting the flow diagram into a set of differential equations and then solve them numerically using the package deSolve. library(deSolve) library(tidyverse) ### Model specification plant_soil_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dP00_dt = P0A*dA + PA0*mA - P00*(PA0 + PAA)*RA dPA0_dt = P00*(PA0 + PAA)*RA - PA0*mA - PA0*CA dPAA_dt = PA0*CA - PAA*mA + P0A*(PA0 + PAA)*RA*a dP0A_dt = PAA*mA - P0A*(PA0 + PAA)*RA*a - P0A*dA return(list(c(dP00_dt, dPA0_dt, dPAA_dt, dP0A_dt))) }) } ### Model parameters times &lt;- seq(0, 20, by = 0.1) state &lt;- c(P00 = 0.25, PA0 = 0.25, PAA = 0.25, P0A = 0.25) parms &lt;- c(RA = 0.5, mA = 0.1, CA = 0.5, dA = 0.4, a = 0.7) ### ODE solver patch_prop &lt;- ode(func = plant_soil_model, times = times, y = state, parms = parms) ### Visualization patch_prop %&gt;% as.data.frame() %&gt;% pivot_longer(cols = -time, names_to = &quot;patch&quot;, values_to = &quot;prop&quot;) %&gt;% ggplot(aes(x = time, y = prop, color = fct_reorder(patch, prop, last, .desc = T))) + geom_line(size = 1.5) + theme_classic(base_size = 12) + labs(x = &quot;Time&quot;, y = &quot;Proportion&quot;) + scale_x_continuous(limits = c(0, 20.5), expand = c(0, 0)) + scale_y_continuous(limits = c(0, 0.8), expand = c(0, 0)) + scale_color_brewer(name = NULL, palette = &quot;Set1&quot;) Additional readings Otto &amp; Day Chapter 2 - How to Construct a Model Assignments No assignments this week. "],["week-7.html", "Week 7 Lecture in a nutshell Lab demonstration Additional readings Assignments", " Week 7 Lotka-Volterra model of competition: graphical analysis Lecture in a nutshell Model derivation Per capita growth rate of two competing species A and B (linear competitive effect): \\(\\frac {1}{N_{A}} \\frac {dN_{A}}{dt} = r_{A}-\\alpha_{AA}N_{A}-\\alpha_{AB}N_{B}\\) \\(\\frac {1}{N_{B}} \\frac {dN_{B}}{dt} = r_{B}-\\alpha_{BB}N_{B}-\\alpha_{BA}N_{A}\\) Coefficient \\(\\alpha_{ij}\\) represents the effect of species \\(j\\) on species \\(i\\): \\(\\frac {d}{dN_{j}}\\frac {1}{N_{i}} \\frac {dN_{i}}{dt}\\) Intraspecific interaction: \\(i = j\\); Interspecific interaction: \\(i \\ne j\\) Categorizing types of interspecific interaction: Mutualism: both \\(\\alpha_{AB}\\) and \\(\\alpha_{BA}\\) is positive Consumer-Resource: one of \\(\\alpha_{AB}\\) and \\(\\alpha_{BA}\\) is positive and the other is negative Competition: both \\(\\alpha_{AB}\\) and \\(\\alpha_{BA}\\) is negative Find the equilibrium points of the system by solving the simultaneous equations: \\(\\frac {dN_{A}}{dt} = 0\\) and \\(\\frac {dN_{B}}{dt} = 0\\) Four equilibrium points \\((N_{A}^{*}, N_{B}^{*})\\): \\(E_{0} = (0, 0)\\) \\(E_{A} = (\\frac {r_{A}}{\\alpha_{AA}}, 0)\\) \\(E_{B} = (0, \\frac {r_{B}}{\\alpha_{BB}})\\) \\(E_{AB} = (\\frac {r_{A}r_{B}(\\frac {\\alpha_{BB}}{r_{B}}-\\frac {\\alpha_{AB}}{r_{A}})}{\\alpha_{AA} \\alpha_{BB} - \\alpha_{AB}\\alpha_{BA}}, \\frac {r_{A}r_{B}(\\frac {\\alpha_{AA}}{r_{A}}-\\frac {\\alpha_{BA}}{r_{B}})}{\\alpha_{AA} \\alpha_{BB} - \\alpha_{AB}\\alpha_{BA}})\\) State-space diagrams (phase plane) and isoclines State-space diagrams: state variables \\((N_{A}, N_{B})\\) as axes Zero net growth isoclines (ZNGIs): combinations of state variables that lead to zero growth (of the focal state variable) Four ZNGIs (two for each species): ZNGIs for species A: \\(N_{A} = 0\\) and \\(r_{A}-\\alpha_{AA}N_{A}-\\alpha_{AB}N_{B} = 0\\) ZNGIs for species B: \\(N_{B} = 0\\) and \\(r_{B}-\\alpha_{BB}N_{B}-\\alpha_{BA}N_{A} = 0\\) Graphical analysis Four cases: Species A wins: \\(E_{A} = (\\frac {r_{A}}{\\alpha_{AA}}, 0)\\) when \\(\\frac {r_{A}}{\\alpha_{AA}} &gt; \\frac {r_{B}}{\\alpha_{BA}}\\) and \\(\\frac {r_{A}}{\\alpha_{AB}} &gt; \\frac {r_{B}}{\\alpha_{BB}}\\) Species B wins: \\(E_{B} = (0, \\frac {r_{B}}{\\alpha_{BB}})\\) when \\(\\frac {r_{A}}{\\alpha_{AA}} &lt; \\frac {r_{B}}{\\alpha_{BA}}\\) and \\(\\frac {r_{A}}{\\alpha_{AB}} &lt; \\frac {r_{B}}{\\alpha_{BB}}\\) Species A and B coexist (stable): \\(E_{AB} = (\\frac {r_{A}r_{B}(\\frac {\\alpha_{BB}}{r_{B}}-\\frac {\\alpha_{AB}}{r_{A}})}{\\alpha_{AA} \\alpha_{BB} - \\alpha_{AB}\\alpha_{BA}}, \\frac {r_{A}r_{B}(\\frac {\\alpha_{AA}}{r_{A}}-\\frac {\\alpha_{BA}}{r_{B}})}{\\alpha_{AA} \\alpha_{BB} - \\alpha_{AB}\\alpha_{BA}})\\) when \\(\\frac {r_{B}}{\\alpha_{BA}} &gt; \\frac {r_{A}}{\\alpha_{AA}}\\) and \\(\\frac {r_{A}}{\\alpha_{AB}} &gt; \\frac {r_{B}}{\\alpha_{BB}}\\) Species A and B coexist (unstable; there are alternative stable states \\(E_{A}\\) and \\(E_{B}\\) depending on the initial condition): \\(E_{AB} = (\\frac {r_{A}r_{B}(\\frac {\\alpha_{BB}}{r_{B}}-\\frac {\\alpha_{AB}}{r_{A}})}{\\alpha_{AA} \\alpha_{BB} - \\alpha_{AB}\\alpha_{BA}}, \\frac {r_{A}r_{B}(\\frac {\\alpha_{AA}}{r_{A}}-\\frac {\\alpha_{BA}}{r_{B}})}{\\alpha_{AA} \\alpha_{BB} - \\alpha_{AB}\\alpha_{BA}})\\) when \\(\\frac {r_{B}}{\\alpha_{BA}} &lt; \\frac {r_{A}}{\\alpha_{AA}}\\) and \\(\\frac {r_{A}}{\\alpha_{AB}} &lt; \\frac {r_{B}}{\\alpha_{BB}}\\) Take-home message: For the two species to coexist stably, the (intraspecific) effect each species imposes on itself should be greater than the (interspecific) effect it imposes on the other species. Lab demonstration Here are the state-space diagrams and vector fields of the systems in which (1) two species exhibit stable coexistence and (2) two species exhibit unstable coexistence (saddle). library(tidyverse) library(deSolve) phase_plane &lt;- function(r1, r2, a11, a21, a22, a12, title, shape){ ### Vectors LV_competition_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN1_dt = N1*(r1-a11*N1-a12*N2) dN2_dt = N2*(r2-a22*N2-a21*N1) return(list(c(dN1_dt, dN2_dt))) }) } times &lt;- seq(0, 0.1, by = 0.1) parms &lt;- c(r1 = r1, r2 = r2, a11 = a11, a21 = a21, a22 = a22, a12 = a12) vector_grid &lt;- expand.grid(seq(5, 505, 20), seq(5, 505, 20)) vector_data &lt;- vector_grid %&gt;% pmap(., function(Var1, Var2){ state &lt;- c(N1 = Var1, N2 = Var2) pop_size &lt;- ode(func = LV_competition_model, times = times, y = state, parms = parms) pop_size[2, 2:3] }) %&gt;% bind_rows() %&gt;% rename(xend = N1, yend = N2) %&gt;% bind_cols(vector_grid) %&gt;% rename(x = Var1, y = Var2) ### Phase plane ggplot() + geom_abline(slope = -a11/a12, intercept = r1/a12, color = &quot;#E41A1C&quot;, size = 1.5) + geom_abline(slope = -a21/a22, intercept = r2/a22, color = &quot;#377EB8&quot;, size = 1.5) + geom_segment(data = vector_data, aes(x = x, y = y, xend = xend, yend = yend), arrow = arrow(length = unit(0.1, &quot;cm&quot;))) + geom_point(aes(x = (a22*r1-a12*r2)/(a11*a22-a12*a21), y = (a21*r1-a11*r2)/(a12*a21-a11*a22)), color = &quot;red&quot;, size = 4, shape = shape, stroke = 2) + scale_x_continuous(name = &quot;N1&quot;, limits = c(0, 505), expand = c(0, 0)) + scale_y_continuous(name = &quot;N2&quot;, limits = c(0, 505), expand = c(0, 0)) + theme_bw(base_size = 13) + theme(panel.grid = element_blank(), plot.title = element_text(hjust = 0.5)) + labs(title = title) } phase_plane(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/300, a22 = 1/200, a12 = 1/300, title = &quot;Stable coexistence&quot;, shape = 16) phase_plane(r1 = 1.2, r2 = 1.2, a11 = 1/300, a21 = 1/200, a22 = 1/300, a12 = 1/200, title = &quot;Unstable coexistence (saddle)&quot;, shape = 1) Additional readings On Competition between Different Species of Graminivorous Insects Assignments Graphical Analysis of Lotka-Volterra Competition Model Suggested Solutions "],["week-8.html", "Week 8 Lecture in a nutshell Lab demonstration Additional readings Assignments", " Week 8 Lotka-Volterra model of competition: linear stability analysis Lecture in a nutshell The differential equations \\(f_{A}(N_{A}, N_{B}) = \\frac {dN_{A}}{dt} = N_{A}(r_{A}-\\alpha_{AA}N_{A}-\\alpha_{AB}N_{B})\\) \\(f_{B}(N_{A}, N_{B}) = \\frac {dN_{B}}{dt} = N_{B}(r_{B}-\\alpha_{BB}N_{B}-\\alpha_{BA}N_{A})\\) Analytical analysis (1): Invasion analysis Idea: can a species invade the others equilibrium? Invasion growth rate (IGR): the growth rate of focal species when rare \\(IGR_{i} = \\lim_{N_{i} \\to 0} \\frac {1}{N_{i}} \\frac {dN_{i}}{dt}|_{N_{j}}\\) \\(IGR_{A} = \\lim_{N_{A} \\to 0} \\frac {1}{N_{A}} \\frac {dN_{A}}{dt}|_{E_{B}} = r_{A}-r_{B}(\\frac{\\alpha_{AB}}{\\alpha_{BB}})\\rightarrow\\) Species A can invade when \\(\\frac{\\alpha_{BB}}{r_{B}} &gt; \\frac{\\alpha_{AB}}{r_{A}}\\) \\(IGR_{B} = \\lim_{N_{B} \\to 0} \\frac {1}{N_{B}} \\frac {dN_{B}}{dt}|_{E_{A}} = r_{B}-r_{A}(\\frac{\\alpha_{BA}}{\\alpha_{AA}}) \\rightarrow\\) Species B can invade when \\(\\frac{\\alpha_{AA}}{r_{A}} &gt; \\frac{\\alpha_{BA}}{r_{B}}\\) System dynamics: \\(IGR_{A} &gt; 0\\) and \\(IGR_{B} &lt; 0\\): Species A wins \\(IGR_{A} &lt; 0\\) and \\(IGR_{B} &gt; 0\\): Species B wins \\(IGR_{A} &gt; 0\\) and \\(IGR_{B} &gt; 0\\): Two species coexist (mutual invasibility) \\(IGR_{A} &lt; 0\\) and \\(IGR_{B} &lt; 0\\): Priority effect (founder control) Analytical analysis (2): Local stability analysis Behavior of a small displacement \\(\\epsilon\\) near the equilibrium: \\(\\frac{d\\epsilon}{dt} = \\frac{d}{dt} \\begin{vmatrix}\\epsilon_{A}\\\\ \\epsilon_{B}\\end{vmatrix} = \\begin{vmatrix}\\frac {\\partial f_{A}}{\\partial N_{A}} &amp; \\frac {\\partial f_{A}}{\\partial N_{B}}\\\\\\frac {\\partial f_{B}}{\\partial N_{A}} &amp; \\frac {\\partial f_{B}}{\\partial N_{B}}\\end{vmatrix}_{(N_{A}^{*}, N_{B}^{*})} \\begin{vmatrix}\\epsilon_{A}\\\\ \\epsilon_{B}\\end{vmatrix} = J\\begin{vmatrix}\\epsilon_{A}\\\\ \\epsilon_{B}\\end{vmatrix}\\) General solution for \\(\\begin{vmatrix}\\epsilon_{A}\\\\ \\epsilon_{B}\\end{vmatrix}\\): \\(w1\\begin{vmatrix}C_{1}\\\\ D_{1}\\end{vmatrix}e^{\\lambda_{1}t} + w2\\begin{vmatrix}C_{2}\\\\ D_{2}\\end{vmatrix}e^{\\lambda_{2}t} \\\\\\) where \\(\\lambda_{1}\\) and \\(\\lambda_{2}\\) are the two eigenvalues of \\(J\\), \\(w1\\) and \\(w2\\) are constant, and \\(\\begin{vmatrix}C_{1}\\\\ D_{1}\\end{vmatrix}\\) and \\(\\begin{vmatrix}C_{2}\\\\ D_{2}\\end{vmatrix}\\) are the corresponding eigenvectors \\(\\to \\lambda&#39;s\\) govern the dynamics of the displacement In our example model, \\(J = \\begin{vmatrix}-N_{A}\\alpha_{AA}+r_{A}-\\alpha_{AA}N_{A}-\\alpha_{AB}N_{B} &amp; -N_{A}\\alpha_{AB}\\\\-N_{B}\\alpha_{BA} &amp; -N_{B}\\alpha_{BB}+r_{B}-\\alpha_{BB}N_{B}-\\alpha_{BA}N_{A}\\end{vmatrix}\\) Steps for local stability analysis: Find the equilibrium points \\(E^{*}\\) Evaluate \\(J\\) at \\(E^{*}\\) Find the eigenvalues of \\(J|_{E^{*}}\\) Determine the stability of \\(E^{*}\\): Stable if all real parts of \\(\\lambda&#39;s\\) &lt; 0 Unstable if at least one real part of \\(\\lambda&#39;s\\) &gt; 0 Spiral trajectory if the imaginary parts of \\(\\lambda&#39;s\\) is non-zero (this can be proven by the Eulers equation \\(e^{ix} = cos(x) + isin(x)\\)) Local stability analysis of the four equilibrium points \\(E_{0} = (0, 0)\\): \\(J_{E_{0}} = \\begin{vmatrix}r_{A} &amp; 0 \\\\ 0 &amp; r_{B}\\end{vmatrix}\\) \\(\\lambda&#39;s = r_{A}\\) and \\(r_{B}\\) (both &gt; 0) Unstable \\(E_{A} = (\\frac {r_{A}}{\\alpha_{AA}}, 0)\\): \\(J_{E_{A}} = \\begin{vmatrix}-r_{A} &amp; -\\alpha_{AB}(\\frac {r_{A}}{\\alpha_{AA}}) \\\\ 0 &amp; r_{B}-\\alpha_{BA}(\\frac {r_{A}}{\\alpha_{AA}})\\end{vmatrix}\\) \\(\\lambda&#39;s = -r_{A}\\) and \\(r_{B}-\\alpha_{BA}(\\frac {r_{A}}{\\alpha_{AA}})\\) Stability criteria: \\(\\frac {\\alpha_{BA}}{r_{B}} &gt; \\frac {\\alpha_{AA}}{r_{A}}\\) \\(E_{B} = (0, \\frac {r_{B}}{\\alpha_{BB}})\\): \\(J_{E_{B}} = \\begin{vmatrix}r_{A}-\\alpha_{AB}(\\frac {r_{B}}{\\alpha_{BB}}) &amp; 0 \\\\ -\\alpha_{BA}(\\frac {r_{B}}{\\alpha_{BB}}) &amp; -r_{B} \\end{vmatrix}\\) \\(\\lambda&#39;s = -r_{B}\\) and \\(r_{A}-\\alpha_{AB}(\\frac {r_{B}}{\\alpha_{BB}})\\) Stability criteria: \\(\\frac {\\alpha_{AB}}{r_{A}} &gt; \\frac {\\alpha_{BB}}{r_{B}}\\) \\(E_{AB} = (\\frac {r_{A}r_{B}(\\frac {\\alpha_{BB}}{r_{B}}-\\frac {\\alpha_{AB}}{r_{A}})}{\\alpha_{AA} \\alpha_{BB} - \\alpha_{AB}\\alpha_{BA}}, \\frac {r_{A}r_{B}(\\frac {\\alpha_{AA}}{r_{A}}-\\frac {\\alpha_{BA}}{r_{B}})}{\\alpha_{AA} \\alpha_{BB} - \\alpha_{AB}\\alpha_{BA}}) = (N_{A}^*, N_{B}^*)\\): \\(J_{E_{AB}} = \\begin{vmatrix}-\\alpha_{AA}N_{A}^* &amp; -\\alpha_{AB}N_{B}^* \\\\ -\\alpha_{BA}N_{B}^* &amp; -\\alpha_{BB}N_{B}^* \\end{vmatrix}\\) Characteristic equation: \\(\\lambda^2+(\\alpha_{AA}N_{A}^*+\\alpha_{BB}N_{B}^*)\\lambda+N_{A}^*N_{B}^*(\\alpha_{AA}\\alpha_{BB}-\\alpha_{AB}\\alpha_{BA}) = 0\\) \\(\\lambda_{1} + \\lambda_{2}=\\frac {-b}{a} = -(\\alpha_{AA}N_{A}^*+\\alpha_{BB}N_{B}^*)\\); \\(\\lambda_{1}\\lambda_{2}=\\frac {c}{a} = N_{A}^*N_{B}^*(\\alpha_{AA}\\alpha_{BB}-\\alpha_{AB}\\alpha_{BA})\\) For both \\(\\lambda&#39;s &lt; 0\\), we need \\(\\lambda_{1} + \\lambda_{2} &lt; 0\\) and \\(\\lambda_{1}\\lambda_{2} &gt; 0\\): \\(\\lambda_{1} + \\lambda_{2} &lt; 0\\) \\(\\to\\) \\(N_{A}^*\\) and \\(N_{B}^* &gt; 0\\) \\(\\to\\) \\(\\frac {\\alpha_{BB}}{r_{B}} &gt; \\frac {\\alpha_{AB}}{r_{A}}\\) and \\(\\frac {\\alpha_{AA}}{r_{A}} &gt; \\frac {\\alpha_{BA}}{r_{B}}\\) [feasibility] \\(\\lambda_{1}\\lambda_{2} &gt; 0\\) \\(\\to\\) \\(\\alpha_{AA}\\alpha_{BB}-\\alpha_{AB}\\alpha_{BA} &gt; 0\\) [stabilization] Summary of stability criteria .book-body .page-wrapper .page-inner section.normal table th { border: 1px solid white !important; } .book-body .page-wrapper .page-inner section.normal table th div { border: 1px solid white !important; } \\(\\frac {\\alpha_{BB}}{r_{B}} - \\frac {\\alpha_{AB}}{r_{A}}\\) \\(+\\) \\(-\\) \\(\\frac {\\alpha_{AA}}{r_{A}} - \\frac {\\alpha_{BA}}{r_{B}}\\) \\(+\\) \\(\\bullet\\) \\(E_{A}\\) and \\(E_{B}\\) unstable \\(\\bullet\\) \\(E_{AB}\\) feasible and stable \\(\\bullet\\) \\(IGR_{A}\\) &gt; 0 and \\(IGR_{B}\\) &gt; 0 \\(\\bullet\\) Stable coexistence \\(\\bullet\\) \\(E_{A}\\) unstable and \\(E_{B}\\) stable \\(\\bullet\\) \\(E_{AB}\\) unfeasible \\(\\bullet\\) \\(IGR_{A}\\) &lt; 0 and \\(IGR_{B}\\) &gt; 0 \\(\\bullet\\) Species B wins \\(-\\) \\(\\bullet\\) \\(E_{A}\\) stable and \\(E_{B}\\) unstable \\(\\bullet\\) \\(E_{AB}\\) unfeasible \\(\\bullet\\) \\(IGR_{A}\\) &gt; 0 and \\(IGR_{B}\\) &lt; 0 \\(\\bullet\\) Species A wins \\(\\bullet\\) \\(E_{A}\\) and \\(E_{B}\\) stable \\(\\bullet\\) \\(E_{AB}\\) feasible but unstable \\(\\bullet\\) \\(IGR_{A}\\) &lt; 0 and \\(IGR_{B}\\) &lt; 0 \\(\\bullet\\) Priority effect Lab demonstration In this lab, we are going to analyze the two-species Lotka-Volterra competition model numerically and visualize the population dynamics under different parameter settings. library(tidyverse) library(deSolve) LV_pop_dynamics &lt;- function(r1 = 1.4, r2 = 1.2, a11 = 1/200, a21 = 1/400, a22 = 1/200, a12 = 1/300, N1_0 = 10, N2_0 = 10) { ### Model specification LV_competition_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN1_dt = N1*(r1-a11*N1-a12*N2) dN2_dt = N2*(r2-a22*N2-a21*N1) return(list(c(dN1_dt, dN2_dt))) }) } ### Model parameters times &lt;- seq(0, 100, by = 0.1) state &lt;- c(N1 = N1_0, N2 = N2_0) parms &lt;- c(r1 = r1, r2 = r2, a11 = a11, a21 = a21, a22 = a22, a12 = a12) ### Model application pop_size &lt;- ode(func = LV_competition_model, times = times, y = state, parms = parms) ### Visualize the population dynamics pop_size %&gt;% as.data.frame() %&gt;% pivot_longer(cols = -time, names_to = &quot;species&quot;, values_to = &quot;N&quot;) %&gt;% ggplot(aes(x = time, y = N, color = species)) + geom_line(size = 1.5) + theme_classic(base_size = 12) + labs(x = &quot;Time&quot;, y = &quot;Population size&quot;) + scale_x_continuous(limits = c(0, 100.5), expand = c(0, 0)) + scale_y_continuous(limits = c(0, max(pop_size)*1.2), expand = c(0, 0)) + scale_color_brewer(name = NULL, palette = &quot;Set1&quot;) } ### Different parameter settings LV_pop_dynamics(r1 = 1.4, r2 = 1.2, a11 = 1/200, a21 = 1/400, a22 = 1/200, a12 = 1/300, N1_0 = 10, N2_0 = 10) # stable coexistence LV_pop_dynamics(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/100, a12 = 1/300, N1_0 = 10, N2_0 = 10) # N1 wins LV_pop_dynamics(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/500, a22 = 1/500, a12 = 1/300, N1_0 = 10, N2_0 = 10) # N2 wins Additional readings No additional readings this week. Assignments Linear Stability Analysis of Lotka-Volterra Competition Model Suggested Solutions "],["week-9.html", "Week 9", " Week 9 Midterm Midterm Suggested Solutions "],["week-10.html", "Week 10 Lecture in a nutshell Lab demonstration Additional readings Assignments", " Week 10 Modern coexistence theory &amp; Lotka-Volterra model of predator-prey interactions (1) Lecture in a nutshell Modern coexistence theory From mutual invasion analysis for coexistence: \\(\\frac{\\alpha_{AB}}{\\alpha_{BB}}&lt;\\frac{r_{A}}{r_{B}}&lt;\\frac{\\alpha_{AA}}{\\alpha_{BA}}\\) Multiplying all terms by \\(\\sqrt{\\frac{\\alpha_{BB}\\alpha_{BA}}{\\alpha_{AA}\\alpha_{AB}}}\\): \\(\\sqrt{\\frac{\\alpha_{AB}\\alpha_{BA}}{\\alpha_{AA}\\alpha_{BB}}}&lt;\\frac{r_{A}}{r_{B}}\\sqrt{\\frac{\\alpha_{BB}\\alpha_{BA}}{\\alpha_{AA}\\alpha_{AB}}}&lt;\\sqrt{\\frac{\\alpha_{AA}\\alpha_{BB}}{\\alpha_{AB}\\alpha_{BA}}}\\) \\(\\sqrt{\\frac{\\alpha_{AB}\\alpha_{BA}}{\\alpha_{AA}\\alpha_{BB}}}\\): niche overlap (\\(\\rho\\)) (niche difference: \\(1-\\rho\\)) \\(\\frac{r_{A}}{r_{B}}\\): demographic ratio \\(\\sqrt{\\frac{\\alpha_{BB}\\alpha_{BA}}{\\alpha_{AA}\\alpha_{AB}}}\\): sensitivity to competition \\(\\frac{r_{A}}{r_{B}}\\sqrt{\\frac{\\alpha_{BB}\\alpha_{BA}}{\\alpha_{AA}\\alpha_{AB}}}\\): fitness ratio/competitive hierarchy (\\(\\frac{K_{A}}{K_{B}}\\)) Coexistence: fitness ratio \\(\\frac{K_{A}}{K_{B}}\\) should be bounded between \\(\\rho\\) and \\(\\frac{1}{\\rho}\\) Competition outcomes: Lotka-Volterra model of predator-prey interactions Model derivation: \\(\\begin{align}\\frac {dN}{dt} = g(N)-f(N,P)\\end{align}\\\\\\) \\(\\begin{align}\\frac {dP}{dt} = ef(N,P)-d(P)\\end{align}\\) \\(g(N)\\): prey growth \\(f(N,P)\\): prey consumed by predator \\(ef(N,P)\\): prey conversion into predator \\(d(P)\\): predator mortality Functional response \\(f(N,P)\\): Type I: \\(f(N,P) = aN\\) Type II: \\(f(N,P) = \\frac{aN}{1+ahN}\\) (h is the handling time) or \\(\\frac{uN}{K_{m}+N}\\) Type III: \\(f(N,P) = \\frac{aN^{2}}{1+ahN^{2}}\\) or \\(\\frac{uN^{2}}{K_{m}+N^{2}}\\) Various model forms: Exponential growth of prey + Type I functional response Logistic growth of prey + Type I functional response Exponential growth of prey + Type II functional response Logistic growth of prey + Type II functional response Model 1. Exponential growth of prey + Type I functional response Model equations: \\(\\begin{align}\\frac {dN}{dt} = rN-aNP\\end{align}\\\\\\) \\(\\begin{align}\\frac {dP}{dt} = eaNP-dP\\end{align}\\) The equilibrium points \\((N^{*}, P^{*})\\): \\(E_{0} = (0, 0)\\) \\(E_{NP} = (\\frac{d}{ea}, \\frac{r}{a})\\) Local stability analysis: \\(E_{0}\\) \\(J_{E_{0}} = \\begin{vmatrix}r &amp; 0 \\\\ 0 &amp; -d\\end{vmatrix}\\) \\(\\lambda&#39;s = r\\) and \\(-d\\) (one positive and one negative) Unstable \\(E_{NP}\\) \\(J_{E_{NP}} = \\begin{vmatrix}0 &amp; -a\\frac{d}{ea} \\\\ ea\\frac{r}{a} &amp; 0\\end{vmatrix}\\) \\(\\lambda&#39;s = \\sqrt{rd}*i\\) Real part is zero (pure imaginary number): the equilibrium is a center; sensitive to non-linear terms/initial conditions Lyapunov function (global stability analysis of the equilibrium) is useful for predicting the system dynamics in the situations where all real parts of the eigenvalues are zero In this case, the dynamics are neutral cycles Lab demonstration In this lab, we are going to analyze the classic Lotka-Volterra predator-prey model: \\(\\begin{align}\\frac {dN}{dt} = rN-aNP\\end{align}\\\\\\) \\(\\begin{align}\\frac {dP}{dt} = eaNP-dP\\end{align}\\) Please simulate the model using the following parameter set (N = 10, P = 2, r = 1.0, a = 0.1, e = 0.8, d = 0.5) and plot the population trajectories of predator and prey over time. Also show their population dynamics in the state-space diagram. What will happen if you add a perturbation to the system (i.e., change the initial conditions)? Try out different values of N and P and visualize the differences in the state-space diagram. library(tidyverse) library(deSolve) ### Model specification LV_predation_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N - a*N*P dP_dt = e*a*N*P - d*P return(list(c(dN_dt, dP_dt))) }) } ### Model parameters times &lt;- seq(0, 1000, by = 0.005) state &lt;- c(N = 10, P = 2) parms &lt;- c(r = 1.0, a = 0.1, e = 0.8, d = 0.5) ### Model application pop_size &lt;- ode(func = LV_predation_model, times = times, y = state, parms = parms) ### Visualize the population dynamics # (1) population trajectories pop_size %&gt;% as.data.frame() %&gt;% pivot_longer(cols = -time, names_to = &quot;species&quot;, values_to = &quot;N&quot;) %&gt;% ggplot(aes(x = time, y = N, color = species)) + geom_line(size = 1.5) + theme_classic(base_size = 12) + labs(x = &quot;Time&quot;, y = &quot;Population size&quot;) + scale_x_continuous(limits = c(0, 100.5), expand = c(0, 0)) + scale_y_continuous(limits = c(0, max(pop_size[, -1])*1.2), expand = c(0, 0)) + scale_color_brewer(name = NULL, palette = &quot;Set1&quot;, labels = c(&quot;Prey&quot;, &quot;Predator&quot;), direction = -1) # (2) state-space diagram pop_size %&gt;% as.data.frame() %&gt;% ggplot(aes(x = N, y = P)) + geom_path() + theme_classic(base_size = 12) + labs(x = &quot;Prey&quot;, y = &quot;Predator&quot;) iframe {border: 0;} Here is a shiny app for the Lotka-Volterra predator-prey model. Feel free to play around with different parameter inputs and see how the system dynamics change accordingly. Additional readings Signs of stabilisation and stable coexistence Assignments Stabilizing Lotka-Volterra Predator-Prey Model Suggested Solutions "],["week-11.html", "Week 11 Lecture in a nutshell Lab demonstration Additional readings Assignments", " Week 11 Lotka-Volterra model of predator-prey interactions (2) Lecture in a nutshell (Continued from Week 10) Model 2. Logistic growth of prey + Type I functional response Model equations: \\(\\begin{align}\\frac {dN}{dt} = rN(1-\\frac{N}{K})-aNP\\end{align}\\\\\\) \\(\\begin{align}\\frac {dP}{dt} = eaNP-dP\\end{align}\\) The equilibrium points \\((N^{*}, P^{*})\\): \\(E_{0} = (0, 0)\\) \\(E_{N} = (K, 0)\\) \\(E_{NP} = (\\frac{d}{ea}, \\frac{r}{a}(1-\\frac{d}{eak}))\\) Local stability analysis: \\(E_{0}\\) \\(J_{E_{0}} = \\begin{vmatrix}r &amp; 0 \\\\ 0 &amp; -d\\end{vmatrix}\\) \\(\\lambda&#39;s = r\\) and \\(-d\\) (one positive and one negative) Unstable \\(E_{N}\\) \\(J_{E_{N}} = \\begin{vmatrix}-r &amp; -aK \\\\ 0 &amp; eaK-d\\end{vmatrix}\\) \\(\\lambda&#39;s = -r\\) and \\(eaK-d\\) Stable if \\(eaK &lt; d~(K &lt; \\frac{d}{ea})\\) \\(E_{NP}\\) \\(J_{E_{NP}} = \\begin{vmatrix}-\\frac{rd}{eaK} &amp; -\\frac{d}{e} \\\\ eaP^{*} &amp; 0\\end{vmatrix}\\) Characteristic equation: \\(\\lambda^{2} - (\\frac{rd}{eaK})\\lambda + adP^{*} = 0\\) \\(\\lambda_{1} + \\lambda_{2} = -\\frac{rd}{eaK} &lt; 0~\\&amp;~\\lambda_{1}\\lambda_{2} = adP^{*} &gt; 0\\) Stable if \\(P^{*} &gt; 0\\) (feasibility) and \\(K &gt; \\frac{d}{ea}\\) Model 3. Exponential growth of prey + Type II functional response Model equations: \\(\\begin{align}\\frac {dN}{dt} = rN-(\\frac{aN}{1+ahN})P\\end{align}\\\\\\) \\(\\begin{align}\\frac {dP}{dt} = e(\\frac{aN}{1+ahN})P-dP\\end{align}\\) Internal equilibrium is unstable (oscillations with increasing amplitude) Model 4. Logistic growth of prey + Type II functional response Model equations: \\(\\begin{align}\\frac {dN}{dt} = rN(1-\\frac{N}{K})-(\\frac{aN}{1+ahN})P\\end{align}\\\\\\) \\(\\begin{align}\\frac {dP}{dt} = e(\\frac{aN}{1+ahN})P-dP\\end{align}\\) The equilibrium points \\((N^{*}, P^{*})\\): \\(E_{0} = (0, 0)\\) \\(E_{N} = (K, 0)\\) \\(E_{NP} = (\\frac{d}{a(e-dh)}, \\frac{r}{a}(1-\\frac{d}{a(e-dh)k})(1+ah\\frac{d}{a(e-dh)}))\\) Local stability analysis: \\(E_{0}\\) \\(J_{E_{0}} = \\begin{vmatrix}r &amp; 0 \\\\ 0 &amp; -d\\end{vmatrix}\\) \\(\\lambda&#39;s = r\\) and \\(-d\\) Unstable \\(E_{N}\\) \\(J_{E_{N}} = \\begin{vmatrix}-r &amp; \\frac{-aK}{1+ahK} \\\\ 0 &amp; \\frac{eaK}{1+ahK}-d\\end{vmatrix}\\) \\(\\lambda&#39;s = -r\\) and \\(\\frac{eaK}{1+ahK}-d\\) Stable if \\((K &lt; \\frac{d}{a(e-dh)})\\) \\(E_{NP}\\) \\(J_{E_{NP}} = \\begin{vmatrix}N^{*}(\\frac{-r}{K}+\\frac{a^{2}hP^{*}}{(1+ahN^{*})^{2}}) &amp; -\\frac{aN^{*}}{1+ahN^{*}} \\\\ \\frac{eaP^{*}}{(1+ahN^{*})^{2}} &amp; 0\\end{vmatrix}\\) Characteristic equation: \\(\\lambda^{2} - N^{*}(\\frac{-r}{K}+\\frac{a^{2}hP^{*}}{(1+ahN^{*})^{2}})\\lambda + \\frac{ea^{2}N^{*}P^{*}}{(1+ahN^{*})^{3}} = 0\\) If feasible (\\(N^{*}, P^{*} &gt; 0\\)), \\(E_{NP}\\) is stable if \\(\\frac{-r}{K}+\\frac{a^{2}hP^{*}}{(1+ahN^{*})^{2}} &lt; 0\\) (or \\(N^{*} &gt; \\frac{-1+ahk}{2ah}\\)) Paradox of enrichment: increasing the carrying capacity K of prey will destabilize the system PoincarÃ©Bendixson theorem: the trajectory must exhibit sustained periodic motion in a bounded 2D state-space if there is no equilibrium within. Lab demonstration Similar to what weve done in the previous class, in this lab we are going to analyze the RosenzweigMacArthur predatorprey model: \\(\\begin{align}\\frac {dN}{dt} = rN(1-\\frac{N}{K})-a\\frac{N}{1+ahN}P\\end{align}\\\\\\) \\(\\begin{align}\\frac {dP}{dt} = ea\\frac{N}{1+ahN}P-dP\\end{align}\\) Please simulate the model using the parameter set (N = 5, P = 2, r = 1.0, K = 5.0, a = 1.3, h = 0.9, e = 0.6, d = 0.5) and plot the population trajectories of predator and prey as well as show their population dynamics in the state-space diagram. What will happen if you add a perturbation to the system (i.e., change the initial conditions)? Try out different values of N and P and visualize the differences in the state-space diagram. Also compare the results of the RosenzweigMacArthur model and the original Lotka-Volterra model. What do you find regarding the final equilibrium cycles? library(tidyverse) library(deSolve) ### Model specification RM_predation_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N*(1-(N/K))-(a*N/(1+a*h*N))*P dP_dt = e*(a*N/(1+a*h*N))*P-d*P return(list(c(dN_dt, dP_dt))) }) } ### Model parameters times &lt;- seq(0, 200, by = 0.01) state &lt;- c(N = 5, P = 2) parms &lt;- c(r = 1.0, K = 5.0, a = 1.3, h = 0.9, e = 0.6, d = 0.5) ### Model application pop_size &lt;- ode(func = RM_predation_model, times = times, y = state, parms = parms) ### Visualize the population dynamics # (1) population trajectories pop_size %&gt;% as.data.frame() %&gt;% pivot_longer(cols = -time, names_to = &quot;species&quot;, values_to = &quot;N&quot;) %&gt;% ggplot(aes(x = time, y = N, color = species)) + geom_line(size = 1.5) + theme_classic(base_size = 12) + labs(x = &quot;Time&quot;, y = &quot;Population size&quot;) + scale_x_continuous(limits = c(0, 200.5), expand = c(0, 0)) + scale_y_continuous(limits = c(0, max(pop_size[, -1])*1.2), expand = c(0, 0)) + scale_color_brewer(name = NULL, palette = &quot;Set1&quot;, labels = c(&quot;Prey&quot;, &quot;Predator&quot;), direction = -1) # (2) state-space diagram pop_size %&gt;% as.data.frame() %&gt;% ggplot(aes(x = N, y = P)) + geom_path() + geom_vline(xintercept = with(as.list(parms), d/(e*a-a*d*h)), color = &quot;#E41A1C&quot;, size = 1) + geom_function(data = data.frame(x = seq(0, 5, 0.01)), aes(x = x), fun = function(n){with(as.list(parms), r*(1+a*h*n)*(1-n/K)/a)}, inherit.aes = F, color = &quot;#377EB8&quot;, size = 1) + geom_point(aes(x = tail(N, 1), y = tail(P, 1)), size = 2) + theme_classic(base_size = 14) + theme(axis.line.x = element_line(color = &quot;#E41A1C&quot;, size = 1), axis.line.y = element_line(color = &quot;#377EB8&quot;, size = 1)) + labs(x = &quot;Prey&quot;, y = &quot;Predator&quot;) + scale_x_continuous(limits = c(0, max(pop_size[, &quot;N&quot;]*1.05)), expand = c(0, 0)) + scale_y_continuous(limits = c(0, max(pop_size[, &quot;P&quot;]*1.05)), expand = c(0, 0)) iframe {border: 0;} Special topic: time-scale separation Time-scale separation is a useful technique to reduce the dimension of the model system, where some state variables are assumed to operate at a much shorter time scale (i.e., fast variables) compared with the others (i.e., slow variables). The fast variables will adjust rapidly to their new equilibria in response to a slight change in the slow variables, such that the slow variables can be viewed as constants from the perspective of fast variables. Here, we are going to use the Lotka-Volterra model with logistic prey growth to demonstrate time-scale separation: \\(\\begin{align}\\frac {dN}{dt} = rN(1-\\frac{N}{K})-aNP\\end{align}\\\\\\) \\(\\begin{align}\\frac {dP}{dt} = eaNP-dP\\end{align}\\) We will treat prey as a fast variable and predator as a slow variable. First, we find the quasi-equilibrium \\(N^{\\wedge}\\) of prey by setting the prey equation to zero: \\(\\begin{align}N^{\\wedge} = K(1-\\frac{aP}{r}) \\end{align}\\) And then we plug \\(N^{\\wedge}\\) into predator equation: \\(\\begin{align}\\frac {dP}{dt} = (eaK-d)P(1-\\frac{eaK(\\frac{a}{r})}{eaK-d}P)\\end{align}\\) What do you see in the above equation? It is actually a logistic growth model! So under time-scale separation, predator will exhibit logistic population growth. We will show this shortly in the code below. One simple way to achieve time-scale separation in this model is to increase the prey growth rate so that prey will grow much faster than predator, mimicking the shorter generation time of prey relative to that of predator. library(tidyverse) library(deSolve) Prey_logistic_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N*(1-(N/K))-a*N*P dP_dt = e*a*N*P-d*P return(list(c(dN_dt, dP_dt))) }) } times &lt;- seq(0, 100, by = 0.01) state &lt;- c(N = 40, P = 20) parms &lt;- c(r = 40.0, K = 60, a = 0.1, e = 0.1, d = 0.5) # r is chosen to be sufficiently large for time-scale separation pop_size &lt;- ode(func = Prey_logistic_model, times = times, y = state, parms = parms) # population trajectories pop_size %&gt;% as.data.frame() %&gt;% pivot_longer(cols = -time, names_to = &quot;species&quot;, values_to = &quot;N&quot;) %&gt;% ggplot(aes(x = time, y = N, color = species)) + geom_line(size = 1.5) + theme_classic(base_size = 12) + labs(x = &quot;Time&quot;, y = &quot;Population size&quot;) + scale_x_continuous(limits = c(0, 100.5), expand = c(0, 0)) + scale_y_continuous(limits = c(0, max(pop_size[, -1])*1.2), expand = c(0, 0)) + scale_color_brewer(name = NULL, palette = &quot;Set1&quot;, labels = c(&quot;Prey&quot;, &quot;Predator&quot;), direction = -1) # state-space diagram pop_size %&gt;% as.data.frame() %&gt;% ggplot(aes(x = N, y = P)) + geom_point(color = &quot;grey60&quot;, size = 3, shape = 21) + geom_vline(xintercept = with(as.list(parms), d/(e*a)), color = &quot;#E41A1C&quot;, size = 1) + geom_abline(slope = with(as.list(parms), -r/(a*K)), intercept = with(as.list(parms), r/a), color = &quot;#377EB8&quot;, size = 1) + geom_point(aes(x = with(as.list(parms), d/(e*a)), y = with(as.list(parms), -r/(a*K)*d/(e*a) + r/a)), size = 4) + theme_classic(base_size = 14) + theme(axis.line.x = element_line(color = &quot;#E41A1C&quot;, size = 1), axis.line.y = element_line(color = &quot;#377EB8&quot;, size = 1)) + labs(x = &quot;Prey&quot;, y = &quot;Predator&quot;) + scale_y_continuous(limits = c(NA, 100)) If we solve for the new predator growth equation derived under time-scale separation using the same parameter set and visualize the population trajectory, we will get almost exactly the same predator growth pattern as that in the original model. Time_scale_logistic &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dP_dt = (e*a*K-d)*P*(1-((e*a*K*(a/r))/(e*a*K-d))*P) return(list(c(dP_dt))) }) } times &lt;- seq(0, 100, by = 0.1) state &lt;- c(N = 40, P = 20) state_timescale &lt;- c(P = 20) parms &lt;- c(r = 40.0, K = 60, a = 0.1, e = 0.1, d = 0.5) # r is chosen to be sufficiently large for time-scale separation pop_size_original &lt;- ode(func = Prey_logistic_model, times = times, y = state, parms = parms) pop_size_timescale &lt;- ode(func = Time_scale_logistic, times = times, y = state_timescale, parms = parms) # plot the two predator population trajectories in the same figure pop_size_timescale %&gt;% as.data.frame() %&gt;% mutate(P_original = pop_size_original[, &quot;P&quot;]) %&gt;% rename(P_timescale = P) %&gt;% pivot_longer(cols = -time, names_to = &quot;model&quot;, values_to = &quot;n&quot;) %&gt;% ggplot(aes(x = time, y = n, color = model)) + geom_point(size = 2.5, alpha = 0.8, shape = 21) + theme_classic(base_size = 14) + labs(x = &quot;Time&quot;, y = &quot;Population size&quot;) + scale_x_continuous(limits = c(0, 100.5), expand = c(0, 0)) + scale_y_continuous(limits = c(0, max(pop_size_timescale[, -1])*1.2), expand = c(0, 0)) + scale_color_brewer(name = NULL, palette = &quot;Set2&quot;, labels = c(&quot;Original&quot;, &quot;Time-scale&quot;)) When you gradually shift r from small to large values, you can see that the population dynamics of predator and prey change quite dramatically. Some interesting patterns will arise! Additional readings No additional readings this week. Assignments No assignments this week. "],["week-12.html", "Week 12 Lecture in a nutshell Lab demonstration Additional readings Assignments", " Week 12 Resource competition: R* models Lecture in a nutshell Exploitative competition (consumer-resource dynamics) R* rule: 2 consumers + 1 resource \\(\\begin{align}\\frac {dN_{1}}{dt} = e_{1}a_{1}RN_{1}-dN_{1}\\end{align}\\\\\\) \\(\\begin{align}\\frac {dN_{2}}{dt} = e_{2}a_{2}RN_{2}-dN_{2}\\end{align}\\\\\\) \\(\\begin{align}\\frac {dR}{dt} = d(S_{0}-R)-a_{1}RN_{1}-a_{2}RN_{2}\\end{align}\\) The two consumers CANNOT coexist: the one with lower R* (the resource level at the monoculture equilibrium) will win Generalization: When multiple species are competing for a single resource, coexistence is not possible. The species with the lowest R* will win at equilibrium. Tilmans resource ratio hypothesis: 2 consumers + 2 resources \\(\\begin{align}\\frac {dN_{1}}{dt} = e_{1}a_{1a}R_{a}N_{1}+e_{1}a_{1b}R_{b}N_{1}-dN_{1}\\end{align}\\\\\\) \\(\\begin{align}\\frac {dN_{2}}{dt} = e_{2}a_{2a}R_{a}N_{2}+e_{2}a_{2b}R_{b}N_{2}-dN_{2}\\end{align}\\\\\\) \\(\\begin{align}\\frac {dR_{a}}{dt} = d(S_{a}-R_{a})-a_{1a}R_{a}N_{1}-a_{2a}R_{a}N_{2}\\end{align}\\) \\(\\begin{align}\\frac {dR_{b}}{dt} = d(S_{b}-R_{b})-a_{1b}R_{b}N_{1}-a_{2b}R_{b}N_{2}\\end{align}\\) Outcomes: Consumer 1 wins: \\(ZNGI_{2}\\) lies above \\(ZNGI_{1}\\) in the \\(R_{a}\\)-\\(R_{b}\\) state space Consumer 2 wins: \\(ZNGI_{1}\\) lies above \\(ZNGI_{2}\\) in the \\(R_{a}\\)-\\(R_{b}\\) state space Coexist: \\(ZNGI_{1}\\) and \\(ZNGI_{2}\\) cross (trade-off in competitiveness); species should consume more of the resource that limits its growth (i.e., the resource of which the decline leads to the largest reduction in growth); resource supply should be balanced Priority effect Armstrong &amp; McGehee relative nonlinearity 2 consumers + 1 resource \\(\\begin{align}\\frac {dN_{1}}{dt} = e_{1}a_{1}RN_{1}-d_{1}N_{1}\\end{align}\\\\\\) \\(\\begin{align}\\frac {dN_{2}}{dt} = e_{2}\\frac{a_{2}R}{k_{2}+R}N_{2}-d_{2}N_{2}\\end{align}\\\\\\) \\(\\begin{align}\\frac {dR}{dt} = rR(1-\\frac{R}{K})-a_{1}RN_{1}-\\frac{a_{2}R}{k_{2}+R}N_{2}\\end{align}\\) Logistically-growing resource + type-II functional response of one consumer Fluctuating resource generates stable limit cycles (fluctuating-dependent coexistence): coexistence occurs if \\(R^{**}\\) &lt; \\(R^{*}\\) &lt; \\(\\bar{R}\\) Lab demonstration Part 1 - R* rule In this part of the lab section, we are going to analyze the consumer-resource dynamics with two consumers and one resource: \\(\\begin{align}\\frac {dN_{1}}{dt} = e_{1}a_{1}RN_{1}-dN_{1}\\end{align}\\\\\\) \\(\\begin{align}\\frac {dN_{2}}{dt} = e_{2}a_{2}RN_{2}-dN_{2}\\end{align}\\\\\\) \\(\\begin{align}\\frac {dR}{dt} = d(S_{0}-R)-a_{1}RN_{1}-a_{2}RN_{2}\\end{align}\\) Please simulate the model using the parameter set (N1 = 2, N2 = 2, R = 0.1, a1 = 0.4, a2 = 0.6, e1 = 1, e2 = 1, d = 0.01, S0 = 0.1) and visualize the population trajectories of the two consumers as well as the resource. Below is a plot of resource level vs.Â consumers per capita growth rate. What would you predict about the system dynamics? library(tidyverse) library(deSolve) ### Parameters a1 &lt;- 0.4 a2 &lt;- 0.6 e1 &lt;- 1 e2 &lt;- 1 d &lt;- 0.01 S0 &lt;- 0.1 ### Resource level vs. consumers&#39; per capita population growth data.frame(R = seq(0, 0.1, 0.001)) %&gt;% mutate(N1 = e1*a1*R-d, N2 = e2*a2*R-d) %&gt;% pivot_longer(-R, names_to = &quot;species&quot;, values_to = &quot;N&quot;) %&gt;% ggplot(aes(x = R, y = N, color = species)) + geom_line(size = 1.2) + geom_hline(yintercept = 0, linetype = &quot;dashed&quot;) + labs(x = &quot;Resource level&quot;, y = &quot;Per capita growth rate&quot;) + scale_x_continuous(limits = c(0, 0.11), expand = c(0, 0)) + scale_y_continuous(limits = c(NA, 0.05), expand = c(0, 0)) + scale_color_brewer(name = NULL, palette = &quot;Set1&quot;, direction = -1) + theme_classic(base_size = 14) ### Model specification CR_model_2C_1R &lt;- function(times, state, parms){ with(as.list(c(state, parms)), { dN1_dt = e1*a1*R*N1 - d*N1 dN2_dt = e2*a2*R*N2 - d*N2 dR_dt = d*(S0-R) - a1*R*N1 - a2*R*N2 return(list(c(dN1_dt, dN2_dt, dR_dt))) }) } ### Model parameters times &lt;- seq(0.1, 1000, by = 0.1) state &lt;- c(N1 = 2, N2 = 2, R = 0.1) parms &lt;- c(a1 = 0.4, a2 = 0.6, e1 = 1, e2 = 1, d = 0.01, S0 = 0.1) # R and S0 should be the same in the chemostat ### Model application pop_size &lt;- ode(func = CR_model_2C_1R, times = times, y = state, parms = parms) ### Visualize the population dynamics pop_size %&gt;% as.data.frame() %&gt;% pivot_longer(cols = -time, names_to = &quot;species&quot;, values_to = &quot;N&quot;) %&gt;% mutate(trophic = case_when(species %in% c(&quot;N1&quot;, &quot;N2&quot;) ~ &quot;Consumer&quot;, TRUE ~ &quot;Resource&quot;)) %&gt;% ggplot(aes(x = time, y = N, color = species)) + geom_line(size = 1.5) + facet_wrap(~ trophic, ncol = 2, scales = &quot;free_y&quot;, strip.position = &quot;left&quot;) + theme_classic(base_size = 14) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, legend.position = &quot;top&quot;, legend.title = element_blank(), plot.margin = margin(r = 5)) + labs(x = &quot;Time&quot;, y = NULL) + scale_x_continuous(limits = c(0, 1050), expand = c(0, 0)) + scale_y_continuous(limits = c(0, NA), expand = c(0, 0)) + scale_color_manual(name = NULL, values = c(&quot;#377EB8&quot;, &quot;#E41A1C&quot;, &quot;#4DAF4A&quot;)) We can see that N1 goes extinct, as predicted by the R* rule; the remaining consumer N2 and the resource R exhibit stable coexistence. Part 2 - Tilmans resource ratio hypothesis Now we will extend the model in Part 1. into two consumers and two resources: \\(\\begin{align}\\frac {dN_{1}}{dt} = e_{1}a_{1a}R_{a}N_{1}+e_{1}a_{1b}R_{b}N_{1}-dN_{1}\\end{align}\\\\\\) \\(\\begin{align}\\frac {dN_{2}}{dt} = e_{2}a_{2a}R_{a}N_{2}+e_{2}a_{2b}R_{b}N_{2}-dN_{2}\\end{align}\\\\\\) \\(\\begin{align}\\frac {dR_{a}}{dt} = d(S_{a}-R_{a})-a_{1a}R_{a}N_{1}-a_{2a}R_{a}N_{2}\\end{align}\\) \\(\\begin{align}\\frac {dR_{b}}{dt} = d(S_{b}-R_{b})-a_{1b}R_{b}N_{1}-a_{2b}R_{b}N_{2}\\end{align}\\) Here, the two consumers N1 and N2 compete for two substitutable resources R1 and R2. Under certain conditions, the two consumers are able to coexist: library(tidyverse) library(deSolve) ### Model specification CR_model_2C_2R &lt;- function(time, state, parms){ with(as.list(c(state, parms)), { dN1_dt = e1*a1a*Ra*N1 + e1*a1b*Rb*N1 - d*N1 dN2_dt = e2*a2a*Ra*N2 + e2*a2b*Rb*N2 - d*N2 dRa_dt = d*(Sa-Ra) - (a1a*N1*Ra) - (a2a*N2*Ra) dRb_dt = d*(Sb-Rb) - (a1b*N1*Rb) - (a2b*N2*Rb) return(list(c(dN1_dt, dN2_dt, dRa_dt, dRb_dt))) }) } ### Model parameters times &lt;- seq(0.1, 2000, by = 0.01) state &lt;- c(N1 = 0.05, N2 = 0.05, Ra = 0.3, Rb = 0.3) parms &lt;- c(a1a = 0.4, a1b = 0.8, a2a = 0.6, a2b = 0.5, e1 = 1, e2 = 1, d = 0.1, Sa = 0.3, Sb = 0.3) # Ra/Rb and S0a/S0b should be the same in the chemostat ### Model application pop_size &lt;- ode(func = CR_model_2C_2R, times = times, y = state, parms = parms) ### Visualize the population dynamics pop_size %&gt;% as.data.frame() %&gt;% pivot_longer(cols = -time, names_to = &quot;species&quot;, values_to = &quot;N&quot;) %&gt;% mutate(trophic = case_when(species %in% c(&quot;N1&quot;, &quot;N2&quot;) ~ &quot;Consumer&quot;, TRUE ~ &quot;Resource&quot;)) %&gt;% ggplot(aes(x = time, y = N, color = species)) + geom_line(size = 1.5) + facet_wrap(~ trophic, ncol = 2, scales = &quot;free_y&quot;, strip.position = &quot;left&quot;) + theme_classic(base_size = 14) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, legend.position = &quot;top&quot;, legend.title = element_blank(), plot.margin = margin(r = 8)) + labs(x = &quot;Time&quot;, y = NULL) + scale_x_continuous(limits = c(0, 2050), expand = c(0, 0)) + scale_y_continuous(limits = c(0, NA), expand = c(0, 0)) + scale_color_manual(name = NULL, values = c(&quot;#377EB8&quot;, &quot;#E41A1C&quot;, &quot;#4DAF4A&quot;, &quot;#984EA3&quot;)) The phase diagram also illustrates stable coexistence of the two consumers: ### Parameters a1a &lt;- 0.4 a1b &lt;- 0.8 a2a &lt;- 0.6 a2b &lt;- 0.5 e1 &lt;- 1 e2 &lt;- 1 d &lt;- 0.1 ### Slopes and intercepts of the ZNGI&#39;s ZNGI_slope_N1 &lt;- -a1a/a1b ZNGI_intercept_N1 &lt;- d/(e1*a1b) ZNGI_slope_N2 &lt;- -a2a/a2b ZNGI_intercept_N2 &lt;- d/(e2*a2b) ### Consumption vectors eqilibrium_Ra &lt;- (d/e1)*((a1b-a2b)/(a2a*a1b-a2b*a1a)) eqilibrium_Rb &lt;- (d/e2)*((a1a-a2a)/(a2b*a1a-a2a*a1b)) convec_df &lt;- data.frame(x = c(eqilibrium_Ra + 6*a1a*eqilibrium_Ra, eqilibrium_Ra + 6*a2a*eqilibrium_Ra), y = c(eqilibrium_Rb + 6*a1b*eqilibrium_Rb, eqilibrium_Rb + 6*a2b*eqilibrium_Rb), xend = c(eqilibrium_Ra - a1a*eqilibrium_Ra, eqilibrium_Ra - a2a*eqilibrium_Ra), yend = c(eqilibrium_Rb - a1b*eqilibrium_Rb, eqilibrium_Rb - a2b*eqilibrium_Rb), species = c(&quot;N1&quot;, &quot;N2&quot;)) ### Phase diagram ggplot() + geom_abline(slope = ZNGI_slope_N1, intercept = ZNGI_intercept_N1, color = &quot;#377EB8&quot;, size = 1.2) + geom_abline(slope = ZNGI_slope_N2, intercept = ZNGI_intercept_N2, color = &quot;#E41A1C&quot;, size = 1.2) + geom_segment(data = convec_df, aes(x = x, y = y, xend = xend, yend = yend, color = species), linetype = &quot;blank&quot;) + geom_segment(data = convec_df, aes(x = x, y = y, xend = xend, yend = yend, color = species), size = 0.5, linetype = &quot;dashed&quot;, arrow = arrow(type = &quot;closed&quot;, length = unit(0.1, &quot;inches&quot;)), show.legend = F) + geom_path(data = as.data.frame(pop_size), aes(x = Ra, y = Rb)) + geom_point(data = as.data.frame(pop_size), aes(x = last(Ra), y = last(Rb)), size = 2.5) + theme_classic(base_size = 14) + labs(x = expression(italic(R[a])), y = expression(italic(R[b]))) + scale_x_continuous(limits = c(0, 0.5), expand = c(0, 0)) + scale_y_continuous(limits = c(0, 0.5), expand = c(0, 0)) + scale_color_brewer(name = NULL, palette = &quot;Set1&quot;, direction = -1, guide = guide_legend(override.aes = list( linetype = &quot;solid&quot;, size = 1.2))) + coord_fixed(ratio = 1) In this particular case, if the initial resource levels Ra0 and Rb0 fall within the upper area bounded by the two consumption vectors, then the two species will coexist. Part 3 - Relative nonlinearity We have seen in Part 1. that two species cannot coexist on one resource if the consumers consume it in a linear fashion. What if the consumers consume the resource in a non-linear fashion? Could that generate stable coexistence? In this part of the lab section, we will introduce non-linear (type II) functional response into the consumer-resource model in Part 1. for one of the consumers. We also change the resource equation to logistic growth and allow the two consumers to have different conversion efficiencies and mortality rates: \\(\\begin{align}\\frac {dN_{1}}{dt} = e_{1}a_{1}RN_{1}-d_{1}N_{1}\\end{align}\\\\\\) \\(\\begin{align}\\frac {dN_{2}}{dt} = e_{2}\\frac{a_{2}R}{k_{2}+R}N_{2}-d_{2}N_{2}\\end{align}\\\\\\) \\(\\begin{align}\\frac {dR}{dt} = rR(1-\\frac{R}{K})-a_{1}RN_{1}-\\frac{a_{2}R}{k_{2}+R}N_{2}\\end{align}\\) library(tidyverse) library(deSolve) ### Model specification CR_model_nonlinear &lt;- function(times, state, parms){ with(as.list(c(state, parms)), { dN1_dt = e1*a1*R*N1 - d1*N1 dN2_dt = e2*(a2*R/(k2+R))*N2 - d2*N2 dR_dt = r*R*(1-(R/K)) - a1*R*N1 - ((a2*R)/(k2+R))*N2 return(list(c(dN1_dt, dN2_dt, dR_dt))) }) } ### Model parameters times &lt;- seq(0, 5000, by = 0.1) state &lt;- c(N1 = 0.3, N2 = 19, R = 106) parms &lt;- c(a1 = 0.003, a2 = 0.5, k2 = 50, e1 = 0.33, e2 = 0.3, d1 = 0.11, d2 = 0.1, r = 0.1, K = 300) ### Model application pop_size &lt;- ode(func = CR_model_nonlinear, times = times, y = state, parms = parms) pop_size %&gt;% as.data.frame() %&gt;% pivot_longer(cols = -time, names_to = &quot;species&quot;, values_to = &quot;N&quot;) %&gt;% mutate(trophic = case_when(species %in% c(&quot;N1&quot;, &quot;N2&quot;) ~ &quot;Consumer&quot;, TRUE ~ &quot;Resource&quot;)) %&gt;% ggplot(aes(x = time, y = N, color = species)) + geom_line(size = 1.5) + facet_wrap(~ trophic, ncol = 2, scales = &quot;free_y&quot;, strip.position = &quot;left&quot;) + theme_classic(base_size = 14) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, legend.position = &quot;top&quot;, legend.title = element_blank(), plot.margin = margin(r = 5)) + labs(x = &quot;Time&quot;, y = NULL) + scale_x_continuous(limits = c(0, 5050), expand = c(0, 0)) + scale_y_continuous(limits = c(0, NA), expand = c(0, 0)) + scale_color_manual(name = NULL, values = c(&quot;#377EB8&quot;, &quot;#E41A1C&quot;, &quot;#4DAF4A&quot;)) As shown in the figure, the two consumers coexist in a fluctuating manner. In fact, the fluctuating properties generated by the combination of logistically growing resources and different nonlinear functions are critical for the coexistence of n species on k &lt; n resources in certain parameter spaces. Additional readings Competitive Exclusion A Graphical-Mechanistic Approach to Competition and Predation Trade-Offs and Coexistence in Consumer-Resource Models: It all Depends on what and where you Eat Assignments Apparent Competition and P* Rule Suggested Solutions "],["week-13.html", "Week 13 Lecture in a nutshell Lab demonstration Additional readings Assignments", " Week 13 Multispecies models of competition: apparent competition Lecture in a nutshell Model derivation \\(\\begin{align}\\frac {dN_{1}}{dt} = r_{1}N_{1}(1-\\frac{N_{1}}{K_{1}})-a_{1}N_{1}P\\end{align}\\\\\\) \\(\\begin{align}\\frac {dN_{2}}{dt} = r_{2}N_{2}(1-\\frac{N_{2}}{K_{2}})-a_{2}N_{2}P\\end{align}\\\\\\) \\(\\begin{align}\\frac {dP}{dt} = e_{1}a_{1}N_{1}P+e_{2}a_{2}N_{2}P-mp\\end{align}\\) Find the equilibrium points: \\(E_{1} = (\\frac{d}{e_{1}a_{1}}, 0, \\frac{r_{1}}{a_{1}}(1-\\frac{d}{e_{1}a_{1}K_{1}}))\\) \\(E_{2} = (0, \\frac{d}{e_{2}a_{2}}, \\frac{r_{2}}{a_{2}}(1-\\frac{d}{e_{2}a_{2}K_{2}}))\\) \\(E_{c} = (\\frac{d-e_{2}a_{2}K_{2}(1-\\frac{a_{2}r_{1}}{r_{2}a_{1}})}{e_{1}a_{1}+e_{2}a_{2}\\frac{K_{2}a_{2}r_{1}}{K_{1}r_{2}a_{1}}}, \\frac{d-e_{1}a_{1}K_{1}(1-\\frac{a_{1}r_{2}}{r_{1}a_{2}})}{e_{2}a_{2}+e_{1}a_{2}\\frac{K_{1}a_{1}r_{2}}{K_{2}r_{1}a_{2}}}, \\frac{r_{1}}{a_{1}}(1-\\frac{N_{1}^{*}}{K_{1}}))\\) Invasion analysis: \\(N_{2}^{*} \\rightarrow E_{1}\\): \\(IGR_{2} = r_{2}-a_{2}[\\frac{r_{1}}{a_{1}}(1-\\frac{d}{e_{1}a_{1}K_{1}})] &gt; 0\\) \\(N_{1}^{*} \\rightarrow E_{2}\\): \\(IGR_{1} = r_{1}-a_{1}[\\frac{r_{2}}{a_{2}}(1-\\frac{d}{e_{2}a_{2}K_{2}})] &gt; 0\\) Mutual invasion criterion (coexistence): \\(\\frac{r_{1}}{a_{1}}(1-\\frac{d}{e_{1}a_{1}K_{1}})&lt;\\frac{r_{2}}{a_{2}}&lt;\\frac{r_{1}}{a_{1}}(1-\\frac{d}{e_{2}a_{2}K_{2}})^{-1}\\) Local stability analysis: \\(J_{E_{1}} = \\begin{vmatrix} -\\frac{r_{1}}{K_{1}}N_{1}^{*} &amp; 0 &amp; -a_{1}N_{1}^{*}\\\\0 &amp; r_{2}-a_{2}P^{*} &amp; 0\\\\e_{1}a_{1}P^{*} &amp; e_{2}a_{2}P^{*} &amp; 0\\end{vmatrix}\\) Characteristic equation: \\((r_{2}-a_{2}P^{*}-\\lambda)[\\lambda^{2}+\\frac{r_{1}}{K_{1}}N_{1}^{*}\\lambda+e_{1}a_{1}^{2}N_{1}^{*}P^{*}] = 0\\) \\(E_{1}\\) is stable if \\(r_{2}-a_{2}P^{*}&lt;0\\) (i.e., \\(IGR_{2} &lt;0\\)) Same procedure for \\(E_{2}\\) \\(J_{E_{c}} = \\begin{vmatrix} -\\frac{r_{1}}{K_{1}}N_{1}^{*} &amp; 0 &amp; -a_{1}N_{1}^{*}\\\\0 &amp; -\\frac{r_{2}}{K_{2}}N_{2}^{*} &amp; -a_{2}N_{2}^{*}\\\\e_{1}a_{1}P^{*} &amp; e_{2}a_{2}P^{*} &amp; 0\\end{vmatrix}\\) Characteristic equation: \\(\\lambda^{3}+[\\frac{r_{1}}{K_{1}}N_{1}^{*}+\\frac{r_{2}}{K_{2}}N_{2}^{*}]\\lambda^{2}+[\\frac{r_{1}r_{2}}{K_{1}K_{2}}N_{1}^{*}N_{2}^{*}+e_{1}a_{1}^{2}N_{1}^{*}P^{*}+e_{2}a_{2}^{2}N_{2}^{*}P^{*}]\\lambda\\\\+[e_{1}a_{1}^{2}\\frac{r_{2}}{K_{2}}+e_{2}a_{2}^{2}\\frac{r_{1}}{K_{1}}]N_{1}^{*}N_{2}^{*}P^{*} = 0\\) Using the RouthHurwitz stability criterion to determine the sign of the eigenvalues, we arrive at the conclusion that \\(E_{c}\\) is locally stable if it is itself feasible. Lab demonstration Here, we are going to visualize the outcomes of apparent competition between two logistically-growing prey species N1 and N2 under linear predator consumption in the r1/a1 - r2/a2 space: \\(\\begin{align}\\frac {dN_{1}}{dt} = r_{1}N_{1}(1-\\frac{N_{1}}{K_{1}})-a_{1}N_{1}P\\end{align}\\\\\\) \\(\\begin{align}\\frac {dN_{2}}{dt} = r_{2}N_{2}(1-\\frac{N_{2}}{K_{2}})-a_{2}N_{2}P\\end{align}\\\\\\) \\(\\begin{align}\\frac {dP}{dt} = e_{1}a_{1}N_{1}P+e_{2}a_{2}N_{2}P-mp\\end{align}\\) library(tidyverse) library(deSolve) ### 1. Create a function to evaluate the competition outcome Apparent_logistic_func &lt;- function(r1, r2){ # specify the model Apparent_logistic_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN1_dt = r1*N1*(1-N1/K1) - a1*N1*P dN2_dt = r2*N2*(1-N2/K2) - a2*N2*P dP_dt = e1*a1*N1*P + e2*a2*N2*P - m*P return(list(c(dN1_dt, dN2_dt, dP_dt))) }) } # model parameters times &lt;- seq(0, 1000, by = 1) state &lt;- c(N1 = 5, N2 = 5, P = 1) parms &lt;- c(r1 = r1, r2 = r2, a1 = 0.35, a2 = 0.35, e1 = 0.4, e2 = 0.5, m = 0.8, K1 = 15, K2 = 12) # run the ode pop_size &lt;- ode(func = Apparent_logistic_model, times = times, y = state, parms = parms) # get the final population size of N1 and N2 N_final &lt;- nrow(na.omit(pop_size)) # remove NAN&#39;s N1_final &lt;- pop_size[N_final, 2] N2_final &lt;- pop_size[N_final, 3] print(pop_size[N_final, ]) # determine the outcome if (N1_final &lt; 1e-5) { return(&quot;N2_win&quot;) } else if (N2_final &lt; 1e-5) { return(&quot;N1_win&quot;) } else { return(&quot;Coexist&quot;) } } ### 2. Apply the function # the parameter space to simulate over and the resolution r_min &lt;- 0 r_max &lt;- 2.5 n &lt;- 300 start_time &lt;- Sys.time() # the starting time of the simulations comp_out &lt;- expand.grid(r1 = seq(r_min, r_max, length.out = n), r2 = seq(r_min, r_max, length.out = n)) %&gt;% mutate(Outcome = map2_chr(r1, r2, Apparent_logistic_func)) # this is where the simulations actually take place! end_time &lt;- Sys.time() # the ending time of the simulations end_time - start_time # it might take a while! ## Time difference of 35.08638 mins library(ggplot2) ### 3. Visualize the competition outcomes in the grids ggplot(comp_out, aes(xmin = r1/0.5, ymin = r2/0.5, xmax = r1/0.5 + (r_max-r_min)/(n-1)/0.5, ymax = r2/0.5 + (r_max-r_min)/(n-1)/0.5, fill = Outcome)) + geom_rect(show.legend = F, alpha = 0.9) + geom_abline(intercept = 0, slope = (1-0.8/(0.4*0.35*15)), size = 1.2) + geom_abline(intercept = 0, slope = (1-0.8/(0.5*0.35*12))^-1, size = 1.2) + labs(x = expression(r[1]/a[1]), y = expression(r[2]/a[2])) + scale_x_continuous(limits = c(r_min/0.5, (r_max+(r_max-r_min)/(n-1))/0.5 ), expand = c(0, 0)) + scale_y_continuous(limits = c(r_min/0.5, (r_max+(r_max-r_min)/(n-1))/0.5 ), expand = c(0, 0)) + scale_fill_brewer(palette = &quot;Set1&quot;) + theme_bw(base_size = 14) + theme(panel.grid = element_blank()) + coord_fixed(ratio = 1) + annotate(geom = &quot;text&quot;, x = 1, y = 4, label = &quot;bold(bolditalic(N[2])~wins)&quot;, parse = T) + annotate(geom = &quot;text&quot;, x = 4, y = 4, label = &quot;bold(Coexist)&quot;, parse = T) + annotate(geom = &quot;text&quot;, x = 4, y = 1, label = &quot;bold(bolditalic(N[1])~wins)&quot;, parse = T) Note that the area of coexistence depends on the slopes of the boundaries, which are \\(1-\\frac{m_{1}}{e_{1}a_{1}K_{1}}\\) between N1 wins and Coexist, and \\((1-\\frac{m_{2}}{e_{2}a_{2}K_{2}})^{-1}\\) between N2 wins and Coexist. Additional readings Predation, apparent competition, and the structure of prey communities Assignments No assignments this week. "],["week-14.html", "Week 14 Lecture in a nutshell Lab demonstration Additional readings Assignments", " Week 14 Disease dynamics and SIR models Lecture in a nutshell Topic: Topic: Lab demonstration In todays lab, we are going to simulate the SIR model with demography and visualize two types of disease dynamics: (1) the endemic equilibrium, at which the S, I, and R all coexist, and (2) the disease-free equilibrium, at which the disease will die off and only S remains. \\(\\begin{align}\\frac {dS}{dt} = \\theta-\\beta SI-\\delta S\\end{align}\\\\\\) \\(\\begin{align}\\frac {dI}{dt} = \\beta SI-\\rho I-\\gamma I\\end{align}\\\\\\) \\(\\begin{align}\\frac {dR}{dt} = \\rho I-\\delta R\\end{align}\\) library(tidyverse) library(deSolve) SIR_model_fun &lt;- function(theta, beta, delta, rho, gamma, title){ # model specification SIR_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dS_dt = theta - beta*S*I - delta*S dI_dt = beta*S*I - rho*I - gamma*I dR_dt = rho*I - delta*R return(list(c(dS_dt, dI_dt, dR_dt))) }) } # model parameters times &lt;- seq(0, 1000, by = 1) state &lt;- c(S = 25, I = 0.1, R = 0) parms &lt;- c(theta = theta, beta = beta, delta = delta, rho = rho, gamma = gamma) # model application SIR_out &lt;- ode(func = SIR_model, times = times, y = state, parms = parms) # visualization SIR_out %&gt;% as.data.frame() %&gt;% pivot_longer(cols = -time, names_to = &quot;state&quot;, values_to = &quot;N&quot;) %&gt;% mutate(state = fct_relevel(state, &quot;S&quot;, &quot;I&quot;, &quot;R&quot;)) %&gt;% ggplot(aes(x = time, y = N, color = state)) + geom_line(size = 1.5) + theme_classic(base_size = 14) + labs(x = &quot;Time&quot;, y = &quot;N&quot;, title = title) + scale_x_continuous(limits = c(0, 1010), expand = c(0, 0)) + scale_y_continuous(limits = c(0, 55), expand = c(0, 0)) + scale_color_brewer(name = NULL, palette = &quot;Set1&quot;) + theme(plot.title = element_text(hjust = 0.5)) } ### Epidemic equilibrium SIR_model_fun(theta = 0.25, beta = 0.01, delta = 0.01, rho = 0.02, gamma = 0.02, title = &quot;Epidemic equilibrium&quot;) ### Disease-free equilibrium SIR_model_fun(theta = 0.25, beta = 0.01, delta = 0.01, rho = 0.3, gamma = 0.02, title = &quot;Disease-free equilibrium&quot;) By increasing the recovery rate \\(\\rho\\) in the second example, we drive the basic reproduction number \\(R_{0}\\) below 1, and thus the disease will not spread and the system reaches the disease-free equilibrium. Additional readings Population biology of infectious diseases: Part I Population biology of infectious diseases: Part II Assignments No assignments this week. "],["week-15.html", "Week 15 Lab review Additional readings Assignments", " Week 15 Course review &amp; open discussion Lab review Throughout the lab sections this semester, we have been focusing largely on solving differential equations using the package deSolve and visualize the system dynamics with ggplots. We have also used for loops to model discrete-time population growth. Lastly, we have analyzed age-structured models using matrix multiplication as well as eigenanalysis to estimate the asymptotic growth rate and stable age distribution. Below is a brief summary of the key points regarding these modeling techniques: 1. deSolve and numerical integration There are two main steps for solving odes with deSolve: Model specification: Create a function specifying your model structure, that is, a set of differential equations Model application: Set the time steps, initial conditions, and model parameters and run the ode() function to solve the system of differential equations p span#aaa:before { content: \"Step 1. \"; display: inline-block; margin-left: -3.5em; margin-right: 0.3em; } p span#bbb:before { content: \"Step 2. \"; display: inline-block; margin-left: -3.5em; margin-right: 0.3em; } d-article table.lightable-paper { margin-bottom: 0px; } Here is an ode example using the Lotka-Volterra competition model: library(deSolve) ### (1) Model specification LV_competition_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { # system of differential equations dN1_dt = N1*(r1-a11*N1-a12*N2) dN2_dt = N2*(r2-a22*N2-a21*N1) # return the integration results (the objects need to be in the same order specified above) return(list(c(dN1_dt, dN2_dt))) }) } ### (2) Model application # parameter setup times &lt;- seq(0, 100, by = 0.1) state &lt;- c(N1 = 10, N2 = 10) parms &lt;- c(r1 = 1.4, r2 = 1.2, a11 = 1/200, a21 = 1/400, a22 = 1/200, a12 = 1/300) # run the ode solver pop_size &lt;- ode(func = LV_competition_model, times = times, y = state, parms = parms) ### Take a look at the results head(pop_size) ## time N1 N2 ## [1,] 0.0 10.00000 10.00000 ## [2,] 0.1 11.40115 11.18554 ## [3,] 0.2 12.98354 12.49917 ## [4,] 0.3 14.76632 13.95156 ## [5,] 0.4 16.76949 15.55348 ## [6,] 0.5 19.01355 17.31557 2. for loops The key to using for loops is to identify what you would like to iterate over (e.g., time) and how many iterations there are (e.g., 100 iterations). Also, we will create an object beforehand to store the results of each for loop iteration. Here is a for loop example using the discrete logistic growth model: library(tidyverse) ### The discrete logistic growth equation and parameter setup log_fun &lt;- function(r, N, K){N + r*N*(1-N/K)} r &lt;- 1.8 K &lt;- 500 N0 &lt;- 10 time &lt;- 100 ### Create an empty object to store the for loop results pop_size &lt;- numeric(time) pop_size[1] &lt;- N0 ### Run the for loop for (i in 2:time) {pop_size[i] &lt;- log_fun(r = r, N = pop_size[i - 1], K = K)} ### Organize the for loop results pop_data &lt;- pop_size %&gt;% as.data.frame() %&gt;% rename(., pop_size = `.`) %&gt;% mutate(time = 0:(time-1)) %&gt;% relocate(time) head(pop_data) ## time pop_size ## 1 0 10.00000 ## 2 1 27.64000 ## 3 2 74.64171 ## 4 3 188.93980 ## 5 4 400.51775 ## 6 5 543.95762 3. Matrix multiplication and eigenanalysis In R, we use %*% (not *!) to do matrix multiplication. Make sure the two matrices are compatible: the number of columns in the first matrix should be the same as the number of rows in the second matrix. If necessary, use t() to transpose the matrix so that the two matrices are compatible for multiplication. To perform eigenanalysis on a square matrix, simply pass the matrix into the function eigen() and store the results to an object. You can then access the eigenvalues and eigenvectors via object_name$values and object_name$vectors. Here is a Leslie matrix example: library(tidyverse) ### Leslie matrix and initial age classes leslie_mtrx &lt;- matrix(data = c(0, 1, 5, 0.5, 0, 0, 0, 0.3, 0), nrow = 3, ncol = 3, byrow = T) initial_age &lt;- c(10, 0, 0) ### for loop and matrix multiplication time &lt;- 50 pop_size &lt;- data.frame(Age1 = numeric(time+1), Age2 = numeric(time+1), Age3 = numeric(time+1)) pop_size[1, ] &lt;- initial_age for (i in 1:time) { # use &quot;%*%&quot; for matrix multiplication # &quot;leslie_mtrx&quot; (3-by-3) is compatible with &quot;as.matrix(t(pop_size[i, ]))&quot; (3-by-1) pop_size[i+1, ] &lt;- leslie_mtrx %*% as.matrix(t(pop_size[i, ])) } ### Organize the for loop results pop_size &lt;- pop_size %&gt;% round() %&gt;% mutate(Total_N = rowSums(.), Time = 0:time) %&gt;% relocate(Time) head(round(pop_size)) ## Time Age1 Age2 Age3 Total_N ## 1 0 10 0 0 10 ## 2 1 0 5 0 5 ## 3 2 5 0 2 7 ## 4 3 8 2 0 10 ## 5 4 2 4 1 7 ## 6 5 8 1 1 10 ### Eigenanalysis of the Leslie matrix eigen_out &lt;- eigen(leslie_mtrx) # dominant eigenvalue eigen_out$values[1] ## [1] 1.089991+0i # corresponding eigenvector eigen_out$vectors[, 1] ## [1] 0.9030054+0i 0.4142263+0i 0.1140082+0i Additional readings Assignments Modeling Idea for an Interesting Ecological Question "],["week-16.html", "Week 16", " Week 16 Final exam "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
