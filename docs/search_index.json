[["week-12.html", "Week 12 Lecture in a nutshell Lab demonstration Additional readings Assignments", " Week 12 Resource competition: R* models Lecture in a nutshell Topic: Topic: Lab demonstration Part 1 - R* rule In this part of the lab section, we are going to analyze the consumer-resource dynamics and demonstrate the R* rule: \\(\\begin{align}\\frac {dN_{1}}{dt} = ea_{1}RN_{1}-dN_{1}\\end{align}\\\\\\) \\(\\begin{align}\\frac {dN_{2}}{dt} = ea_{2}RN_{2}-dN_{2}\\end{align}\\\\\\) \\(\\begin{align}\\frac {dR}{dt} = d(S_{0}-R)-a_{1}RN_{1}-a_{2}RN_{2}\\end{align}\\) Please simulate the model using the parameter set (N1 = 2, N2 = 2, R = 0.1, a1 = 0.4, a2 = 0.6, e = 1, d = 0.01, S0 = 0.1) and visualize the population trajectories of the two consumers as well as the resource. Below is a plot of resource level vs.Â consumers per capita growth rate. What would you predict about the system dynamics? library(tidyverse) library(deSolve) ### Parameters a1 &lt;- 0.4 a2 &lt;- 0.6 e &lt;- 1 d &lt;- 0.01 S0 &lt;- 0.1 ### Resource level vs. consumers&#39; per capita population growth data.frame(R = seq(0, 0.1, 0.001)) %&gt;% mutate(N1 = e*a1*R-d, N2 = e*a2*R-d) %&gt;% pivot_longer(-R, names_to = &quot;species&quot;, values_to = &quot;N&quot;) %&gt;% ggplot(aes(x = R, y = N, color = species)) + geom_line(size = 1.2) + geom_hline(yintercept = 0, linetype = &quot;dashed&quot;) + labs(x = &quot;Resource level&quot;, y = &quot;Per capita growth rate&quot;) + scale_x_continuous(limits = c(0, 0.11), expand = c(0, 0)) + scale_y_continuous(limits = c(NA, 0.05), expand = c(0, 0)) + scale_color_brewer(name = NULL, palette = &quot;Set1&quot;) + theme_classic(base_size = 14) ### Model specification CR_model &lt;- function(times, state, parms){ with(as.list(c(state, parms)), { dN1_dt = e*a1*R*N1 - d*N1 dN2_dt = e*a2*R*N2 - d*N2 dR_dt = d*(S0-R) - a1*R*N1 - a2*R*N2 return(list(c(dN1_dt, dN2_dt, dR_dt))) }) } ### Model parameters times &lt;- seq(0.1, 1000, by = 0.1) state &lt;- c(N1 = 2, N2 = 2, R = 0.1) parms &lt;- c(a1 = 0.4, a2 = 0.6, e = 1, d = 0.01, S0 = 0.1) ### Model application pop_size &lt;- ode(func = CR_model, times = times, y = state, parms = parms) ### Visualize the population dynamics pop_size %&gt;% as.data.frame() %&gt;% pivot_longer(cols = -time, names_to = &quot;species&quot;, values_to = &quot;N&quot;) %&gt;% mutate(trophic = case_when(species %in% c(&quot;N1&quot;, &quot;N2&quot;) ~ &quot;Consumer&quot;, TRUE ~ &quot;Resource&quot;)) %&gt;% ggplot(aes(x = time, y = N, color = species)) + geom_line(size = 1.5) + facet_wrap(~ trophic, ncol = 2, scales = &quot;free_y&quot;, strip.position = &quot;left&quot;) + theme_classic(base_size = 14) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, legend.position = &quot;top&quot;, legend.title = element_blank(), plot.margin = margin(r = 5)) + labs(x = &quot;Time&quot;, y = NULL) + scale_x_continuous(limits = c(0, 1050), expand = c(0, 0)) + scale_y_continuous(limits = c(0, NA), expand = c(0, 0)) + scale_color_brewer(name = NULL, palette = &quot;Set1&quot;) We can see that N1 goes extinct, as predicted by the R* rule; the remaining consumer N2 and the resource R exhibit stable coexistence. Part 2 - Tilmans resource ratio hypothesis library(tidyverse) library(deSolve) ### Model specification RM_predation_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N*(1-(N/K))-(a*N/(1+a*h*N))*P dP_dt = e*(a*N/(1+a*h*N))*P-d*P return(list(c(dN_dt, dP_dt))) }) } ### Model parameters times &lt;- seq(0, 200, by = 0.01) state &lt;- c(N = 5, P = 2) parms &lt;- c(r = 1.0, K = 5.0, a = 1.3, h = 0.9, e = 0.6, d = 0.5) ### Model application pop_size &lt;- ode(func = RM_predation_model, times = times, y = state, parms = parms) ### Visualize the population dynamics # (1) population trajectories pop_size %&gt;% as.data.frame() %&gt;% pivot_longer(cols = -time, names_to = &quot;species&quot;, values_to = &quot;N&quot;) %&gt;% ggplot(aes(x = time, y = N, color = species)) + geom_line(size = 1.5) + theme_classic(base_size = 12) + labs(x = &quot;Time&quot;, y = &quot;Population size&quot;) + scale_x_continuous(limits = c(0, 200.5), expand = c(0, 0)) + scale_y_continuous(limits = c(0, max(pop_size[, -1])*1.2), expand = c(0, 0)) + scale_color_brewer(name = NULL, palette = &quot;Set1&quot;, labels = c(&quot;Prey&quot;, &quot;Predator&quot;), direction = -1) # (2) state-space diagram pop_size %&gt;% as.data.frame() %&gt;% ggplot(aes(x = N, y = P)) + geom_path() + geom_vline(xintercept = with(as.list(parms), d/(e*a-a*d*h)), color = &quot;#E41A1C&quot;, size = 1) + geom_function(data = data.frame(x = seq(0, 5, 0.01)), aes(x = x), fun = function(n){with(as.list(parms), r*(1+a*h*n)*(1-n/K)/a)}, inherit.aes = F, color = &quot;#377EB8&quot;, size = 1) + geom_point(aes(x = tail(N, 1), y = tail(P, 1)), size = 2) + theme_classic(base_size = 14) + theme(axis.line.x = element_line(color = &quot;#E41A1C&quot;, size = 1), axis.line.y = element_line(color = &quot;#377EB8&quot;, size = 1)) + labs(x = &quot;Prey&quot;, y = &quot;Predator&quot;) + scale_x_continuous(limits = c(0, max(pop_size[, &quot;N&quot;]*1.05)), expand = c(0, 0)) + scale_y_continuous(limits = c(0, max(pop_size[, &quot;P&quot;]*1.05)), expand = c(0, 0)) Part 3 - Relative nonlinearity library(tidyverse) library(deSolve) ### Model specification RM_predation_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N*(1-(N/K))-(a*N/(1+a*h*N))*P dP_dt = e*(a*N/(1+a*h*N))*P-d*P return(list(c(dN_dt, dP_dt))) }) } ### Model parameters times &lt;- seq(0, 200, by = 0.01) state &lt;- c(N = 5, P = 2) parms &lt;- c(r = 1.0, K = 5.0, a = 1.3, h = 0.9, e = 0.6, d = 0.5) ### Model application pop_size &lt;- ode(func = RM_predation_model, times = times, y = state, parms = parms) ### Visualize the population dynamics # (1) population trajectories pop_size %&gt;% as.data.frame() %&gt;% pivot_longer(cols = -time, names_to = &quot;species&quot;, values_to = &quot;N&quot;) %&gt;% ggplot(aes(x = time, y = N, color = species)) + geom_line(size = 1.5) + theme_classic(base_size = 12) + labs(x = &quot;Time&quot;, y = &quot;Population size&quot;) + scale_x_continuous(limits = c(0, 200.5), expand = c(0, 0)) + scale_y_continuous(limits = c(0, max(pop_size[, -1])*1.2), expand = c(0, 0)) + scale_color_brewer(name = NULL, palette = &quot;Set1&quot;, labels = c(&quot;Prey&quot;, &quot;Predator&quot;), direction = -1) # (2) state-space diagram pop_size %&gt;% as.data.frame() %&gt;% ggplot(aes(x = N, y = P)) + geom_path() + geom_vline(xintercept = with(as.list(parms), d/(e*a-a*d*h)), color = &quot;#E41A1C&quot;, size = 1) + geom_function(data = data.frame(x = seq(0, 5, 0.01)), aes(x = x), fun = function(n){with(as.list(parms), r*(1+a*h*n)*(1-n/K)/a)}, inherit.aes = F, color = &quot;#377EB8&quot;, size = 1) + geom_point(aes(x = tail(N, 1), y = tail(P, 1)), size = 2) + theme_classic(base_size = 14) + theme(axis.line.x = element_line(color = &quot;#E41A1C&quot;, size = 1), axis.line.y = element_line(color = &quot;#377EB8&quot;, size = 1)) + labs(x = &quot;Prey&quot;, y = &quot;Predator&quot;) + scale_x_continuous(limits = c(0, max(pop_size[, &quot;N&quot;]*1.05)), expand = c(0, 0)) + scale_y_continuous(limits = c(0, max(pop_size[, &quot;P&quot;]*1.05)), expand = c(0, 0)) Additional readings Competitive Exclusion A Graphical-Mechanistic Approach to Competition and Predation Assignments Apparent Competition and P* Rule "]]
